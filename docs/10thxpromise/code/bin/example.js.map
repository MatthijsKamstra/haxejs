{
"version":3,
"file":"example.js",
"sourceRoot":"file:///",
"sources":["/usr/local/lib/haxe/std/js/_std/HxOverrides.hx","/Users/matthijs/Documents/workingdir_haxe/haxejs/docs/10thxpromise/code/src/Main.hx","/usr/local/lib/haxe/std/js/_std/Std.hx","/usr/local/lib/haxe/std/StringBuf.hx","/usr/local/lib/haxe/std/StringTools.hx","/usr/local/lib/haxe/std/haxe/CallStack.hx","/usr/local/lib/haxe/std/js/_std/haxe/Exception.hx","/usr/local/lib/haxe/std/js/_std/haxe/NativeStackTrace.hx","/usr/local/lib/haxe/std/haxe/ValueException.hx","/usr/local/lib/haxe/std/haxe/iterators/ArrayIterator.hx","/usr/local/lib/haxe/std/js/Boot.hx","/usr/local/lib/haxe/lib/thx,core/0,44,0/src/thx/Error.hx","/usr/local/lib/haxe/lib/thx,core/0,44,0/src/thx/Timer.hx","/usr/local/lib/haxe/lib/thx,core/0,44,0/src/thx/error/ErrorWrapper.hx","/usr/local/lib/haxe/lib/thx,promise/0,6,0/src/thx/promise/Future.hx","/usr/local/lib/haxe/lib/thx,promise/0,6,0/src/thx/promise/Promise.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\tstatic function dateStr(date:Date):String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear() + \"-\" + (if (m < 10) \"0\" + m else \"\" + m) + \"-\" + (if (d < 10) \"0\" + d else \"\" + d) + \" \"\n\t\t\t+ (if (h < 10) \"0\" + h else \"\" + h) + \":\" + (if (mi < 10) \"0\" + mi else \"\" + mi) + \":\" + (if (s < 10) \"0\" + s else \"\" + s);\n\t}\n\n\tstatic function strDate(s:String):Date {\n\t\tswitch (s.length) {\n\t\t\tcase 8: // hh:mm:ss\n\t\t\t\tvar k = s.split(\":\");\n\t\t\t\tvar d = js.Syntax.construct(Date);\n\t\t\t\t(cast d)[cast \"setTime\"](0);\n\t\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\n\t\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\n\t\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\n\t\t\t\treturn d;\n\t\t\tcase 10: // YYYY-MM-DD\n\t\t\t\tvar k = s.split(\"-\");\n\t\t\t\treturn new Date(cast k[0], (cast k[1]) - 1, cast k[2], 0, 0, 0);\n\t\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\t\tvar k = s.split(\" \");\n\t\t\t\tvar y = k[0].split(\"-\");\n\t\t\t\tvar t = k[1].split(\":\");\n\t\t\t\treturn new Date(cast y[0], (cast y[1]) - 1, cast y[2], cast t[0], cast t[1], cast t[2]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\t@:pure\n\tstatic function cca(s:String, index:Int):Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif (x != x) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\t@:pure\n\tstatic function substr(s:String, pos:Int, ?len:Int):String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (cast s).substr(pos, len);\n\t}\n\n\t@:pure\n\tstatic function indexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0)\n\t\t\t\ti = 0;\n\t\t}\n\t\twhile (i < len) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@:pure\n\tstatic function lastIndexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>(a:Array<T>, obj:T) {\n\t\tvar i = a.indexOf(obj);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\ta.splice(i, 1);\n\t\treturn true;\n\t}\n\n\t@:pure\n\tstatic function iter<T>(a:Array<T>):Iterator<T>\n\t\tuntyped {\n\t\t\treturn {\n\t\t\t\tcur: 0,\n\t\t\t\tarr: a,\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t\t},\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t@:ifFeature(\"anon_read.keyValueIterator\", \"dynamic_read.keyValueIterator\", \"closure_read.keyValueIterator\")\n\tstatic function keyValueIter<T>( a : Array<T> ) {\n\t\treturn new haxe.iterators.ArrayKeyValueIterator(a);\n\t}\n\n\t@:pure\n\tstatic function now(): Float return js.lib.Date.now();\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__('HxOverrides.indexOf',\n\t\t\t\tif (Array.prototype.indexOf) js.Syntax.code(\"HxOverrides\").indexOf = function(a, o, i) return Array.prototype.indexOf.call(a, o, i));\n\t\t\t__feature__('HxOverrides.lastIndexOf',\n\t\t\t\tif (Array.prototype.lastIndexOf) js.Syntax.code(\"HxOverrides\").lastIndexOf = function(a, o, i) return Array.prototype.lastIndexOf.call(a, o, i));\n\t\t\t#end\n\n\t\t\t__feature__('HxOverrides.now',\n\t\t\t\tif (js.Syntax.typeof(performance) != 'undefined' && js.Syntax.typeof(performance.now) == 'function') {\n\t\t\t\t\tHxOverrides.now = performance.now.bind(performance);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n}\n","package ;\n\nimport thx.Error;\nimport thx.Timer;\n\nusing thx.promise.Promise;\n\nclass Main {\n\n\tpublic function new()\n\t{\n\t\ttrace (\"thx.promise example\");\n\n\t\tvar promise = Promise.create(function(resolve : String -> Void, reject : Error -> Void) {\n\t\t\tTimer.delay(function() {\n\t\t\t\tif(Math.random() < 0.5)\n\t\t\t\t\tresolve(\"success\");\n\t\t\t\telse\n\t\t\t\t\treject(new Error(\"failure\"));\n\t\t\t}, 100);\n\t\t});\n\n\t\tpromise.either(\n\t\t\tfunction(value) trace('SUCCESS $value'),\n\t\t\tfunction(error) trace('ERROR $error')\n\t\t);\n\t}\n\n\tstatic public function main() : Void\n\t{\n\t\tvar main = new Main();\n\t}\n}","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport js.Boot;\nimport js.Syntax;\n\n@:keepInit\n@:coreApi class Std {\n\t@:deprecated('Std.is is deprecated. Use Std.isOfType instead.')\n\tpublic static inline function is(v:Dynamic, t:Dynamic):Bool {\n\t\treturn isOfType(v, t);\n\t}\n\n\tpublic static inline function isOfType(v:Dynamic, t:Dynamic):Bool {\n\t\treturn @:privateAccess js.Boot.__instanceof(v, t);\n\t}\n\n\tpublic static inline function downcast<T:{}, S:T>(value:T, c:Class<S>):S@:privateAccess {\n\t\treturn if (js.Boot.__downcastCheck(value, c)) cast value else null;\n\t}\n\n\t@:deprecated('Std.instance() is deprecated. Use Std.downcast() instead.')\n\tpublic static inline function instance<T:{}, S:T>(value:T, c:Class<S>):S {\n\t\treturn downcast(value, c);\n\t}\n\n\t@:pure\n\tpublic static function string(s:Dynamic):String {\n\t\treturn @:privateAccess js.Boot.__string_rec(s, \"\");\n\t}\n\n\tpublic static inline function int(x:Float):Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\t@:pure\n\tpublic static function parseInt(x:String):Null<Int> {\n\t\tif(x != null) {\n\t\t\tfor(i in 0...x.length) {\n\t\t\t\tvar c = StringTools.fastCodeAt(x, i);\n\t\t\t\tif(c <= 8 || (c >= 14 && c != ' '.code && c != '-'.code)) {\n\t\t\t\t\tvar nc = StringTools.fastCodeAt(x, i + 1);\n\t\t\t\t\tvar v = js.Lib.parseInt(x, (nc == \"x\".code || nc == \"X\".code) ? 16 : 10);\n\t\t\t\t\treturn Math.isNaN(v) ? null : cast v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static inline function parseFloat(x:String):Float {\n\t\treturn js.Syntax.code(\"parseFloat({0})\", x);\n\t}\n\n\tpublic static function random(x:Int):Int {\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random() * x);\n\t}\n\n\tstatic function __init__():Void\n\t\tuntyped {\n\t\t\t__feature__(\"js.Boot.getClass\", String.prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"String\"] = String, String));\n\t\t\t__feature__(\"js.Boot.isClass\", String.__name__ = __feature__(\"Type.getClassName\", \"String\", true));\n\t\t\t__feature__(\"Type.resolveClass\", $hxClasses[\"Array\"] = Array);\n\t\t\t__feature__(\"js.Boot.isClass\", Array.__name__ = __feature__(\"Type.getClassName\", \"Array\", true));\n\t\t\t__feature__(\"Date.*\", {\n\t\t\t\t__feature__(\"js.Boot.getClass\",\n\t\t\t\t\tjs.Syntax.code('Date').prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"Date\"] = js.Syntax.code('Date'), js.Syntax.code('Date')));\n\t\t\t\t__feature__(\"js.Boot.isClass\", js.Syntax.code('Date').__name__ = \"Date\");\n\t\t\t});\n\t\t\t__feature__(\"Int.*\", js.Syntax.code('var Int = { };'));\n\t\t\t__feature__(\"Dynamic.*\", js.Syntax.code('var Dynamic = { };'));\n\t\t\t__feature__(\"Float.*\", js.Syntax.code('var Float = Number'));\n\t\t\t__feature__(\"Bool.*\", js.Syntax.code('var Bool = Boolean'));\n\t\t\t__feature__(\"Class.*\", js.Syntax.code('var Class = { };'));\n\t\t\t__feature__(\"Enum.*\", js.Syntax.code('var Enum = { };'));\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__(\"Array.map\", if (Array.prototype.map == null) Array.prototype.map = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length)\n\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t__feature__(\"Array.filter\", if (Array.prototype.filter == null) Array.prototype.filter = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length) {\n\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\tif (f(e))\n\t\t\t\t\t\ta.push(e);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tA String buffer is an efficient way to build a big string by appending small\n\telements together.\n\n\tUnlike String, an instance of StringBuf is not immutable in the sense that\n\tit can be passed as argument to functions which modify it by appending more\n\tvalues.\n**/\nclass StringBuf {\n\tvar b:String;\n\n\t/**\n\t\tThe length of `this` StringBuf in characters.\n\t**/\n\tpublic var length(get, never):Int;\n\n\t/**\n\t\tCreates a new StringBuf instance.\n\n\t\tThis may involve initialization of the internal buffer.\n\t**/\n\tpublic inline function new() {\n\t\tb = \"\";\n\t}\n\n\tinline function get_length():Int {\n\t\treturn b.length;\n\t}\n\n\t/**\n\t\tAppends the representation of `x` to `this` StringBuf.\n\n\t\tThe exact representation of `x` may vary per platform. To get more\n\t\tconsistent behavior, this function should be called with\n\t\tStd.string(x).\n\n\t\tIf `x` is null, the String \"null\" is appended.\n\t**/\n\tpublic inline function add<T>(x:T):Void {\n\t\tb += x;\n\t}\n\n\t/**\n\t\tAppends the character identified by `c` to `this` StringBuf.\n\n\t\tIf `c` is negative or has another invalid value, the result is\n\t\tunspecified.\n\t**/\n\tpublic inline function addChar(c:Int):Void {\n\t\tb += String.fromCharCode(c);\n\t}\n\n\t/**\n\t\tAppends a substring of `s` to `this` StringBuf.\n\n\t\tThis function expects `pos` and `len` to describe a valid substring of\n\t\t`s`, or else the result is unspecified. To get more robust behavior,\n\t\t`this.add(s.substr(pos,len))` can be used instead.\n\n\t\tIf `s` or `pos` are null, the result is unspecified.\n\n\t\tIf `len` is omitted or null, the substring ranges from `pos` to the end\n\t\tof `s`.\n\t**/\n\tpublic inline function addSub(s:String, pos:Int, ?len:Int):Void {\n\t\tb += (len == null ? s.substr(pos) : s.substr(pos, len));\n\t}\n\n\t/**\n\t\tReturns the content of `this` StringBuf as String.\n\n\t\tThe buffer is not emptied by this operation.\n\t**/\n\tpublic inline function toString():String {\n\t\treturn b;\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport haxe.iterators.StringIterator;\nimport haxe.iterators.StringKeyValueIterator;\n\n#if cpp\nusing cpp.NativeString;\n#end\n\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)\n\tto the `String` class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp && !lua && !eval) inline #end public static function urlEncode(s:String):String {\n\t\t#if flash\n\t\treturn untyped __global__[\"encodeURIComponent\"](s);\n\t\t#elseif neko\n\t\treturn untyped new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\treturn untyped encodeURIComponent(s);\n\t\t#elseif cpp\n\t\treturn untyped s.__URLEncode();\n\t\t#elseif java\n\t\treturn postProcessUrlEncode(java.net.URLEncoder.encode(s, \"UTF-8\"));\n\t\t#elseif cs\n\t\treturn untyped cs.system.Uri.EscapeDataString(s);\n\t\t#elseif python\n\t\treturn python.lib.urllib.Parse.quote(s, \"\");\n\t\t#elseif hl\n\t\tvar len = 0;\n\t\tvar b = @:privateAccess s.bytes.urlEncode(len);\n\t\treturn @:privateAccess String.__alloc__(b, len);\n\t\t#elseif lua\n\t\ts = lua.NativeStringTools.gsub(s, \"\\n\", \"\\r\\n\");\n\t\ts = lua.NativeStringTools.gsub(s, \"([^%w %-%_%.%~])\", function(c) {\n\t\t\treturn lua.NativeStringTools.format(\"%%%02X\", lua.NativeStringTools.byte(c) + '');\n\t\t});\n\t\ts = lua.NativeStringTools.gsub(s, \" \", \"+\");\n\t\treturn s;\n\t\t#else\n\t\treturn null;\n\t\t#end\n\t}\n\n\t#if java\n\tprivate static function postProcessUrlEncode(s:String):String {\n\t\tvar ret = new StringBuf();\n\t\tvar i = 0, len = s.length;\n\t\twhile (i < len) {\n\t\t\tswitch (_charAt(s, i++)) {\n\t\t\t\tcase '+'.code:\n\t\t\t\t\tret.add('%20');\n\t\t\t\tcase '%'.code if (i <= len - 2):\n\t\t\t\t\tvar c1 = _charAt(s, i++), c2 = _charAt(s, i++);\n\t\t\t\t\tswitch [c1, c2] {\n\t\t\t\t\t\tcase ['2'.code, '1'.code]:\n\t\t\t\t\t\t\tret.addChar('!'.code);\n\t\t\t\t\t\tcase ['2'.code, '7'.code]:\n\t\t\t\t\t\t\tret.addChar('\\''.code);\n\t\t\t\t\t\tcase ['2'.code, '8'.code]:\n\t\t\t\t\t\t\tret.addChar('('.code);\n\t\t\t\t\t\tcase ['2'.code, '9'.code]:\n\t\t\t\t\t\t\tret.addChar(')'.code);\n\t\t\t\t\t\tcase ['7'.code, 'E'.code] | ['7'.code, 'e'.code]:\n\t\t\t\t\t\t\tret.addChar('~'.code);\n\t\t\t\t\t\tcase _:\n\t\t\t\t\t\t\tret.addChar('%'.code);\n\t\t\t\t\t\t\tret.addChar(cast c1);\n\t\t\t\t\t\t\tret.addChar(cast c2);\n\t\t\t\t\t}\n\t\t\t\tcase var chr:\n\t\t\t\t\tret.addChar(cast chr);\n\t\t\t}\n\t\t}\n\t\treturn ret.toString();\n\t}\n\t#end\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp && !lua && !eval) inline #end public static function urlDecode(s:String):String {\n\t\t#if flash\n\t\treturn untyped __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif neko\n\t\treturn untyped new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\treturn untyped decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\treturn untyped s.__URLDecode();\n\t\t#elseif java\n\t\ttry\n\t\t\treturn java.net.URLDecoder.decode(s, \"UTF-8\")\n\t\tcatch (e:Dynamic)\n\t\t\tthrow e;\n\t\t#elseif cs\n\t\treturn untyped cs.system.Uri.UnescapeDataString(s);\n\t\t#elseif python\n\t\treturn python.lib.urllib.Parse.unquote(s);\n\t\t#elseif hl\n\t\tvar len = 0;\n\t\tvar b = @:privateAccess s.bytes.urlDecode(len);\n\t\treturn @:privateAccess String.__alloc__(b, len);\n\t\t#elseif lua\n\t\ts = lua.NativeStringTools.gsub(s, \"+\", \" \");\n\t\ts = lua.NativeStringTools.gsub(s, \"%%(%x%x)\", function(h) {\n\t\t\treturn lua.NativeStringTools.char(lua.Lua.tonumber(h, 16));\n\t\t});\n\t\ts = lua.NativeStringTools.gsub(s, \"\\r\\n\", \"\\n\");\n\t\treturn s;\n\t\t#else\n\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape(s:String, ?quotes:Bool):String {\n\t\tvar buf = new StringBuf();\n\t\tfor (code in #if neko iterator(s) #else new haxe.iterators.StringIteratorUnicode(s) #end) {\n\t\t\tswitch (code) {\n\t\t\t\tcase '&'.code:\n\t\t\t\t\tbuf.add(\"&amp;\");\n\t\t\t\tcase '<'.code:\n\t\t\t\t\tbuf.add(\"&lt;\");\n\t\t\t\tcase '>'.code:\n\t\t\t\t\tbuf.add(\"&gt;\");\n\t\t\t\tcase '\"'.code if (quotes):\n\t\t\t\t\tbuf.add(\"&quot;\");\n\t\t\t\tcase '\\''.code if (quotes):\n\t\t\t\t\tbuf.add(\"&#039;\");\n\t\t\t\tcase _:\n\t\t\t\t\tbuf.addChar(code);\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: `htmlUnescape(htmlEscape(s)) == s`\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape(s:String):String {\n\t\treturn s.split(\"&gt;\")\n\t\t\t.join(\">\")\n\t\t\t.split(\"&lt;\")\n\t\t\t.join(\"<\")\n\t\t\t.split(\"&quot;\")\n\t\t\t.join('\"')\n\t\t\t.split(\"&#039;\")\n\t\t\t.join(\"'\")\n\t\t\t.split(\"&amp;\")\n\t\t\t.join(\"&\");\n\t}\n\n\t/**\n\t\tReturns `true` if `s` contains `value` and  `false` otherwise.\n\n\t\tWhen `value` is `null`, the result is unspecified.\n\t**/\n\tpublic static inline function contains(s:String, value:String):Bool {\n\t\t#if (js && js_es >= 6)\n\t\treturn (cast s).includes(value);\n\t\t#else \n\t\treturn s.indexOf(value) != -1;\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is `null`, the result is unspecified.\n\n\t\tIf `start` is the empty String `\"\"`, the result is true.\n\t**/\n\tpublic static #if (cs || java || python || (js && js_es >= 6)) inline #end function startsWith(s:String, start:String):Bool {\n\t\t#if java\n\t\treturn (cast s : java.NativeString).startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#elseif hl\n\t\treturn @:privateAccess (s.length >= start.length && s.bytes.compare(0, start.bytes, 0, start.length << 1) == 0);\n\t\t#elseif python\n\t\treturn python.NativeStringTools.startswith(s, start);\n\t\t#elseif (js && js_es >= 6)\n\t\treturn (cast s).startsWith(start);\n\t\t#else\n\t\treturn (s.length >= start.length && s.lastIndexOf(start, 0) == 0);\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is `null`, the result is unspecified.\n\n\t\tIf `end` is the empty String `\"\"`, the result is true.\n\t**/\n\tpublic static #if (cs || java || python || (js && js_es >= 6)) inline #end function endsWith(s:String, end:String):Bool {\n\t\t#if java\n\t\treturn (cast s : java.NativeString).endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#elseif hl\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn @:privateAccess (slen >= elen && s.bytes.compare((slen - elen) << 1, end.bytes, 0, elen << 1) == 0);\n\t\t#elseif python\n\t\treturn python.NativeStringTools.endswith(s, end);\n\t\t#elseif (js && js_es >= 6)\n\t\treturn (cast s).endsWith(end);\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn (slen >= elen && s.indexOf(end, (slen - elen)) == (slen - elen));\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String `\"\"`, or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace(s:String, pos:Int):Bool {\n\t\t#if (python || lua)\n\t\tif (s.length == 0 || pos < 0 || pos >= s.length)\n\t\t\treturn false;\n\t\t#end\n\t\tvar c = s.charCodeAt(pos);\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls `isSpace()` to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\t\tresult is the empty String `\"\"`.\n\t**/\n\tpublic #if cs inline #end static function ltrim(s:String):String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile (r < l && isSpace(s, r)) {\n\t\t\tr++;\n\t\t}\n\t\tif (r > 0)\n\t\t\treturn s.substr(r, l - r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls `isSpace()` to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\t\tresult is the empty String `\"\"`.\n\t**/\n\tpublic #if cs inline #end static function rtrim(s:String):String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile (r < l && isSpace(s, l - r - 1)) {\n\t\t\tr++;\n\t\t}\n\t\tif (r > 0) {\n\t\t\treturn s.substr(0, l - r);\n\t\t} else {\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for `ltrim(rtrim(s))`.\n\t**/\n\tpublic #if (cs || java) inline #end static function trim(s:String):String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn (cast s : java.NativeString).trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad(s:String, c:String, l:Int):String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\tvar buf = new StringBuf();\n\t\tl -= s.length;\n\t\twhile (buf.length < l) {\n\t\t\tbuf.add(c);\n\t\t}\n\t\tbuf.add(s);\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad(s:String, c:String, l:Int):String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\tvar buf = new StringBuf();\n\t\tbuf.add(s);\n\t\twhile (buf.length < l) {\n\t\t\tbuf.add(c);\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t\tReplace all occurrences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String `\"\"`, `by` is inserted after each character\n\t\tof `s` except the last one. If `by` is also the empty String `\"\"`, `s`\n\t\tremains unchanged.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace(s:String, sub:String, by:String):String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn (cast s : java.NativeString).replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits `length` equals `digits`.\n\t**/\n\tpublic static function hex(n:Int, ?digits:Int) {\n\t\t#if flash\n\t\tvar n:UInt = n;\n\t\tvar s:String = untyped n.toString(16);\n\t\ts = s.toUpperCase();\n\t\t#else\n\t\tvar s = \"\";\n\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\tdo {\n\t\t\ts = hexChars.charAt(n & 15) + s;\n\t\t\tn >>>= 4;\n\t\t} while (n > 0);\n\t\t#end\n\t\t#if python\n\t\tif (digits != null && s.length < digits) {\n\t\t\tvar diff = digits - s.length;\n\t\t\tfor (_ in 0...diff) {\n\t\t\t\ts = \"0\" + s;\n\t\t\t}\n\t\t}\n\t\t#else\n\t\tif (digits != null)\n\t\t\twhile (s.length < digits)\n\t\t\t\ts = \"0\" + s;\n\t\t#end\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than `String.charCodeAt()` on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tEnd of file status can be checked by calling `StringTools.isEof()` with\n\t\tthe returned value as argument.\n\n\t\tThis operation is not guaranteed to work if `s` contains the `\\0`\n\t\tcharacter.\n\t**/\n\tpublic static #if !eval inline #end function fastCodeAt(s:String, index:Int):Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s.cca(index);\n\t\t#elseif java\n\t\treturn (index < s.length) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn (cast(index, UInt) < s.length) ? cast(s[index], Int) : -1;\n\t\t#elseif js\n\t\treturn (cast s).charCodeAt(index);\n\t\t#elseif python\n\t\treturn if (index >= s.length) -1 else python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t\t#elseif hl\n\t\treturn @:privateAccess s.bytes.getUI16(index << 1);\n\t\t#elseif lua\n\t\t#if lua_vanilla\n\t\treturn lua.NativeStringTools.byte(s, index + 1);\n\t\t#else\n\t\treturn lua.lib.luautf8.Utf8.byte(s, index + 1);\n\t\t#end\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than `String.charCodeAt()` on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tThis operation is not guaranteed to work if `s` contains the `\\0`\n\t\tcharacter.\n\t**/\n\tpublic static #if !eval inline #end function unsafeCodeAt(s:String, index:Int):Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s.cca(index);\n\t\t#elseif java\n\t\treturn cast(_charAt(s, index), Int);\n\t\t#elseif cs\n\t\treturn cast(s[index], Int);\n\t\t#elseif js\n\t\treturn (cast s).charCodeAt(index);\n\t\t#elseif python\n\t\treturn python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t\t#elseif hl\n\t\treturn @:privateAccess s.bytes.getUI16(index << 1);\n\t\t#elseif lua\n\t\t#if lua_vanilla\n\t\treturn lua.NativeStringTools.byte(s, index + 1);\n\t\t#else\n\t\treturn lua.lib.luautf8.Utf8.byte(s, index + 1);\n\t\t#end\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns an iterator of the char codes.\n\n\t\tNote that char codes may differ across platforms because of different\n\t\tinternal encoding of strings in different runtimes.\n\t\tFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringIteratorUnicode`.\n\t**/\n\tpublic static inline function iterator(s:String):StringIterator {\n\t\treturn new StringIterator(s);\n\t}\n\n\t/**\n\t\tReturns an iterator of the char indexes and codes.\n\n\t\tNote that char codes may differ across platforms because of different\n\t\tinternal encoding of strings in different of runtimes.\n\t\tFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringKeyValueIteratorUnicode`.\n\t**/\n\tpublic static inline function keyValueIterator(s:String):StringKeyValueIterator {\n\t\treturn new StringKeyValueIterator(s);\n\t}\n\n\t/**\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t**/\n\t@:noUsing public static inline function isEof(c:Int):Bool {\n\t\t#if (flash || cpp || hl)\n\t\treturn c == 0;\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif (neko || lua || eval)\n\t\treturn c == null;\n\t\t#elseif (cs || java || python)\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a String that can be used as a single command line argument\n\t\ton Unix.\n\t\tThe input will be quoted, or escaped if necessary.\n\t**/\n\t@:noCompletion\n\t@:deprecated('StringTools.quoteUnixArg() is deprecated. Use haxe.SysTools.quoteUnixArg() instead.')\n\tpublic static function quoteUnixArg(argument:String):String {\n\t\treturn inline haxe.SysTools.quoteUnixArg(argument);\n\t}\n\n\t/**\n\t\tCharacter codes of the characters that will be escaped by `quoteWinArg(_, true)`.\n\t**/\n\t@:noCompletion\n\t@:deprecated('StringTools.winMetaCharacters is deprecated. Use haxe.SysTools.winMetaCharacters instead.')\n\tpublic static var winMetaCharacters:Array<Int> = cast haxe.SysTools.winMetaCharacters;\n\n\t/**\n\t\tReturns a String that can be used as a single command line argument\n\t\ton Windows.\n\t\tThe input will be quoted, or escaped if necessary, such that the output\n\t\twill be parsed as a single argument using the rule specified in\n\t\thttp://msdn.microsoft.com/en-us/library/ms880421\n\n\t\tExamples:\n\t\t```haxe\n\t\tquoteWinArg(\"abc\") == \"abc\";\n\t\tquoteWinArg(\"ab c\") == '\"ab c\"';\n\t\t```\n\t**/\n\t@:noCompletion\n\t@:deprecated('StringTools.quoteWinArg() is deprecated. Use haxe.SysTools.quoteWinArg() instead.')\n\tpublic static function quoteWinArg(argument:String, escapeMetaCharacters:Bool):String {\n\t\treturn inline haxe.SysTools.quoteWinArg(argument, escapeMetaCharacters);\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16\n\t\treturn (cast str : java.NativeString).charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\", \"url_encode\", 1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\", \"url_decode\", 1);\n\t#end\n\n\t#if utf16\n\tstatic inline var MIN_SURROGATE_CODE_POINT = 65536;\n\n\tstatic inline function utf16CodePointAt(s:String, index:Int):Int {\n\t\tvar c = StringTools.fastCodeAt(s, index);\n\t\tif (c >= 0xD800 && c <= 0xDBFF) {\n\t\t\tc = ((c - 0xD7C0) << 10) | (StringTools.fastCodeAt(s, index + 1) & 0x3FF);\n\t\t}\n\t\treturn c;\n\t}\n\t#end\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\n/**\n\tElements return by `CallStack` methods.\n**/\nenum StackItem {\n\tCFunction;\n\tModule(m:String);\n\tFilePos(s:Null<StackItem>, file:String, line:Int, ?column:Int);\n\tMethod(classname:Null<String>, method:String);\n\tLocalFunction(?v:Int);\n}\n\n/**\n\tGet information about the call stack.\n**/\n@:allow(haxe.Exception)\n@:using(haxe.CallStack)\nabstract CallStack(Array<StackItem>) from Array<StackItem> {\n\t/**\n\t\tThe length of this stack.\n\t**/\n\tpublic var length(get,never):Int;\n\tinline function get_length():Int return this.length;\n\n\t/**\n\t\tReturn the call stack elements, or an empty array if not available.\n\t**/\n\tpublic static function callStack():Array<StackItem> {\n\t\treturn NativeStackTrace.toHaxe(NativeStackTrace.callStack());\n\t}\n\n\t/**\n\t\tReturn the exception stack : this is the stack elements between\n\t\tthe place the last exception was thrown and the place it was\n\t\tcaught, or an empty array if not available.\n\t\tSet `fullStack` parameter to true in order to return the full exception stack.\n\n\t\tMay not work if catch type was a derivative from `haxe.Exception`.\n\t**/\n\tpublic static function exceptionStack( fullStack = false ):Array<StackItem> {\n\t\tvar eStack:CallStack = NativeStackTrace.toHaxe(NativeStackTrace.exceptionStack());\n\t\treturn (fullStack ? eStack : eStack.subtract(callStack())).asArray();\n\t}\n\n\t/**\n\t\tReturns a representation of the stack as a printable string.\n\t**/\n\tstatic public function toString(stack:CallStack):String {\n\t\tvar b = new StringBuf();\n\t\tfor (s in stack.asArray()) {\n\t\t\tb.add('\\nCalled from ');\n\t\t\titemToString(b, s);\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\t/**\n\t\tReturns a range of entries of current stack from the beginning to the the\n\t\tcommon part of this and `stack`.\n\t**/\n\tpublic function subtract(stack:CallStack):CallStack {\n\t\tvar startIndex = -1;\n\t\tvar i = -1;\n\t\twhile(++i < this.length) {\n\t\t\tfor(j in 0...stack.length) {\n\t\t\t\tif(equalItems(this[i], stack[j])) {\n\t\t\t\t\tif(startIndex < 0) {\n\t\t\t\t\t\tstartIndex = i;\n\t\t\t\t\t}\n\t\t\t\t\t++i;\n\t\t\t\t\tif(i >= this.length) break;\n\t\t\t\t} else {\n\t\t\t\t\tstartIndex = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(startIndex >= 0) break;\n\t\t}\n\t\treturn startIndex >= 0 ? this.slice(0, startIndex) : this;\n\t}\n\n\t/**\n\t\tMake a copy of the stack.\n\t**/\n\tpublic inline function copy():CallStack {\n\t\treturn this.copy();\n\t}\n\n\t@:arrayAccess public inline function get(index:Int):StackItem {\n\t\treturn this[index];\n\t}\n\n\tinline function asArray():Array<StackItem> {\n\t\treturn this;\n\t}\n\n\tstatic function equalItems(item1:Null<StackItem>, item2:Null<StackItem>):Bool {\n\t\treturn switch([item1, item2]) {\n\t\t\tcase [null, null]: true;\n\t\t\tcase [CFunction, CFunction]: true;\n\t\t\tcase [Module(m1), Module(m2)]:\n\t\t\t\tm1 == m2;\n\t\t\tcase [FilePos(item1, file1, line1, col1), FilePos(item2, file2, line2, col2)]:\n\t\t\t\tfile1 == file2 && line1 == line2 && col1 == col2 && equalItems(item1, item2);\n\t\t\tcase [Method(class1, method1), Method(class2, method2)]:\n\t\t\t\tclass1 == class2 && method1 == method2;\n\t\t\tcase [LocalFunction(v1), LocalFunction(v2)]:\n\t\t\t\tv1 == v2;\n\t\t\tcase _: false;\n\t\t}\n\t}\n\n\tstatic function exceptionToString(e:Exception):String {\n\t\tif(e.previous == null) {\n\t\t\treturn 'Exception: ${e.toString()}${e.stack}';\n\t\t}\n\t\tvar result = '';\n\t\tvar e:Null<Exception> = e;\n\t\tvar prev:Null<Exception> = null;\n\t\twhile(e != null) {\n\t\t\tif(prev == null) {\n\t\t\t\tresult = 'Exception: ${e.message}${e.stack}' + result;\n\t\t\t} else {\n\t\t\t\tvar prevStack = @:privateAccess e.stack.subtract(prev.stack);\n\t\t\t\tresult = 'Exception: ${e.message}${prevStack}\\n\\nNext ' + result;\n\t\t\t}\n\t\t\tprev = e;\n\t\t\te = e.previous;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic function itemToString(b:StringBuf, s) {\n\t\tswitch (s) {\n\t\t\tcase CFunction:\n\t\t\t\tb.add(\"a C function\");\n\t\t\tcase Module(m):\n\t\t\t\tb.add(\"module \");\n\t\t\t\tb.add(m);\n\t\t\tcase FilePos(s, file, line, col):\n\t\t\t\tif (s != null) {\n\t\t\t\t\titemToString(b, s);\n\t\t\t\t\tb.add(\" (\");\n\t\t\t\t}\n\t\t\t\tb.add(file);\n\t\t\t\tb.add(\" line \");\n\t\t\t\tb.add(line);\n\t\t\t\tif (col != null) {\n\t\t\t\t\tb.add(\" column \");\n\t\t\t\t\tb.add(col);\n\t\t\t\t}\n\t\t\t\tif (s != null)\n\t\t\t\t\tb.add(\")\");\n\t\t\tcase Method(cname, meth):\n\t\t\t\tb.add(cname == null ? \"<unknown>\" : cname);\n\t\t\t\tb.add(\".\");\n\t\t\t\tb.add(meth);\n\t\t\tcase LocalFunction(n):\n\t\t\t\tb.add(\"local function #\");\n\t\t\t\tb.add(n);\n\t\t}\n\t}\n}\n","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\t@:ifFeature('haxe.NativeStackTrace.exceptionStack')\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","package haxe;\n\nimport js.Syntax;\nimport js.lib.Error;\nimport haxe.CallStack.StackItem;\n\n// https://v8.dev/docs/stack-trace-api\n@:native(\"Error\")\nprivate extern class V8Error {\n\tstatic var prepareStackTrace:(error:Error, structuredStackTrace:Array<V8CallSite>)->Any;\n}\n\ntypedef V8CallSite = {\n\tfunction getFunctionName():String;\n\tfunction getFileName():String;\n\tfunction getLineNumber():Int;\n\tfunction getColumnNumber():Int;\n}\n\n/**\n\tDo not use manually.\n**/\n@:dox(hide)\n@:noCompletion\n@:allow(haxe.Exception)\nclass NativeStackTrace {\n\tstatic var lastError:Error;\n\n\t// support for source-map-support module\n\t@:noCompletion\n\tpublic static var wrapCallSite:V8CallSite->V8CallSite;\n\n\t@:ifFeature('haxe.NativeStackTrace.exceptionStack')\n\tstatic public inline function saveStack(e:Error):Void {\n\t\tlastError = e;\n\t}\n\n\tstatic public function callStack():Any {\n\t\tvar e:Null<Error> = new Error('');\n\t\tvar stack = tryHaxeStack(e);\n\t\t//Internet Explorer provides call stack only if error was thrown\n\t\tif(Syntax.typeof(stack) == \"undefined\") {\n\t\t\ttry throw e catch(e:Exception) {}\n\t\t\tstack = e.stack;\n\t\t}\n\t\treturn normalize(stack, 2);\n\t}\n\n\tstatic public function exceptionStack():Any {\n\t\treturn normalize(tryHaxeStack(lastError));\n\t}\n\n\tstatic public function toHaxe(s:Null<Any>, skip:Int = 0):Array<StackItem> {\n\t\tif (s == null) {\n\t\t\treturn [];\n\t\t} else if (Syntax.typeof(s) == \"string\") {\n\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\tvar stack:Array<String> = (s:String).split(\"\\n\");\n\t\t\tif (stack[0] == \"Error\")\n\t\t\t\tstack.shift();\n\t\t\tvar m = [];\n\t\t\tfor (i in 0...stack.length) {\n\t\t\t\tif(skip > i) continue;\n\t\t\t\tvar line = stack[i];\n\t\t\t\tvar matched:Null<Array<String>> = Syntax.code('{0}.match(/^    at ([A-Za-z0-9_. ]+) \\\\(([^)]+):([0-9]+):([0-9]+)\\\\)$/)', line);\n\t\t\t\tif (matched != null) {\n\t\t\t\t\tvar path = matched[1].split(\".\");\n\t\t\t\t\tif(path[0] == \"$hxClasses\") {\n\t\t\t\t\t\tpath.shift();\n\t\t\t\t\t}\n\t\t\t\t\tvar meth = path.pop();\n\t\t\t\t\tvar file = matched[2];\n\t\t\t\t\tvar line = Std.parseInt(matched[3]);\n\t\t\t\t\tvar column = Std.parseInt(matched[4]);\n\t\t\t\t\tm.push(FilePos(meth == \"Anonymous function\" ? LocalFunction() : meth == \"Global code\" ? null : Method(path.join(\".\"), meth), file, line,\n\t\t\t\t\t\tcolumn));\n\t\t\t\t} else {\n\t\t\t\t\tm.push(Module(StringTools.trim(line))); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m;\n\t\t} else if(skip > 0 && Syntax.code('Array.isArray({0})', s)) {\n\t\t\treturn (s:Array<StackItem>).slice(skip);\n\t\t} else {\n\t\t\treturn cast s;\n\t\t}\n\t}\n\n\tstatic function tryHaxeStack(e:Null<Error>):Any {\n\t\tif (e == null) {\n\t\t\treturn [];\n\t\t}\n\t\t// https://v8.dev/docs/stack-trace-api\n\t\tvar oldValue = V8Error.prepareStackTrace;\n\t\tV8Error.prepareStackTrace = prepareHxStackTrace;\n\t\tvar stack = e.stack;\n\t\tV8Error.prepareStackTrace = oldValue;\n\t\treturn stack;\n\t}\n\n\tstatic function prepareHxStackTrace(e:Error, callsites:Array<V8CallSite>):Any {\n\t\tvar stack = [];\n\t\tfor (site in callsites) {\n\t\t\tif (wrapCallSite != null)\n\t\t\t\tsite = wrapCallSite(site);\n\t\t\tvar method = null;\n\t\t\tvar fullName = site.getFunctionName();\n\t\t\tif (fullName != null) {\n\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tvar className = fullName.substring(0, idx);\n\t\t\t\t\tvar methodName = fullName.substring(idx + 1);\n\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t} else {\n\t\t\t\t\tmethod = Method(null, fullName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar fileName = site.getFileName();\n\t\t\tvar fileAddr = fileName == null ? -1 : fileName.indexOf(\"file:\");\n\t\t\tif (wrapCallSite != null && fileAddr > 0)\n\t\t\t\tfileName = fileName.substring(fileAddr + 6);\n\t\t\tstack.push(FilePos(method, fileName, site.getLineNumber(), site.getColumnNumber()));\n\t\t}\n\t\treturn stack;\n\t}\n\n\tstatic function normalize(stack:Any, skipItems:Int = 0):Any {\n\t\tif(Syntax.code('Array.isArray({0})', stack) && skipItems > 0) {\n\t\t\treturn (stack:Array<StackItem>).slice(skipItems);\n\t\t} else if(Syntax.typeof(stack) == \"string\") {\n\t\t\tswitch (stack:String).substring(0, 6) {\n\t\t\t\tcase 'Error:' | 'Error\\n': skipItems += 1;\n\t\t\t\tcase _:\n\t\t\t}\n\t\t\treturn skipLines(stack, skipItems);\n\t\t} else {\n\t\t\t//nothing we can do\n\t\t\treturn stack;\n\t\t}\n\t}\n\n\tstatic function skipLines(stack:String, skip:Int, pos:Int = 0):String {\n\t\treturn if(skip > 0) {\n\t\t\tpos = stack.indexOf('\\n', pos);\n\t\t\treturn pos < 0 ? '' : skipLines(stack, --skip, pos + 1);\n\t\t} else {\n\t\t\treturn stack.substring(pos);\n\t\t}\n\t}\n}","package haxe;\n\n/**\n\tAn exception containing arbitrary value.\n\n\tThis class is automatically used for throwing values, which don't extend `haxe.Exception`\n\tor native exception type.\n\tFor example:\n\t```haxe\n\tthrow \"Terrible error\";\n\t```\n\twill be compiled to\n\t```haxe\n\tthrow new ValueException(\"Terrible error\");\n\t```\n**/\nclass ValueException extends Exception {\n\t/**\n\t\tThrown value.\n\t**/\n\tpublic var value(default,null):Any;\n\n\tpublic function new(value:Any, ?previous:Exception, ?native:Any):Void {\n\t\tsuper(#if js js.Syntax.code('String({0})', value) #else Std.string(value) #end, previous, native);\n\t\tthis.value = value;\n\t}\n\n\t/**\n\t\tExtract an originally thrown value.\n\n\t\tThis method must return the same value on subsequent calls.\n\t\tUsed internally for catching non-native exceptions.\n\t\tDo _not_ override unless you know what you are doing.\n\t**/\n\toverride function unwrap():Any {\n\t\treturn value;\n\t}\n}","/*\n * Copyright (C)2005-2018 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.iterators;\n\n/**\n\tThis iterator is used only when `Array<T>` is passed to `Iterable<T>`\n**/\nclass ArrayIterator<T> {\n\tfinal array:Array<T>;\n\tvar current:Int = 0;\n\n\t/**\n\t\tCreate a new `ArrayIterator`.\n\t**/\n\t#if !hl inline #end\n\tpublic function new(array:Array<T>) {\n\t\tthis.array = array;\n\t}\n\n\t/**\n\t\tSee `Iterator.hasNext`\n\t**/\n\t#if !hl inline #end\n\tpublic function hasNext() {\n\t\treturn current < array.length;\n\t}\n\n\t/**\n\t\tSee `Iterator.next`\n\t**/\n\t#if !hl inline #end\n\tpublic function next() {\n\t\treturn array[current++];\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\n@:dox(hide)\nclass Boot {\n\tstatic inline function isClass(o:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\n\t\tif (o == null) {\n\t\t\treturn null;\n\t\t} else if (Std.isOfType(o, Array)) {\n\t\t\treturn Array;\n\t\t} else {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o, s:String) {\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn \"null\";\n\t\t\tif (s.length >= 5)\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\n\t\t\t\tt = \"object\";\n\t\t\tswitch (t) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\t\tvar con = e.__constructs__[o._hx_index];\n\t\t\t\t\t\tvar n = con._hx_name;\n\t\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t#end\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\n\t\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\t\tif (o.length == 2)\n\t\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\n\t\t\t\t\t\t\t\tif (i != 2)\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t\t});\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor (i in 0...o.length)\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\n\t\t\t\t\t\tstr += \"]\";\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}\n\t\t\t\t\tvar tostr;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t\t} catch (e:Dynamic) {\n\t\t\t\t\t\t// strange error on IE\n\t\t\t\t\t\treturn \"???\";\n\t\t\t\t\t}\n\t\t\t\t\tif (tostr != null && tostr != js.Syntax.code(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\n\t\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\n\t\t\t\t\t\t\treturn s2;\n\t\t\t\t\t}\n\t\t\t\t\tvar str = \"{\\n\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t\tvar k:String = null;\n\t\t\t\t\tjs.Syntax.code(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\n\t\t\t\t\t\tjs.Syntax.code(\"continue\");\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\n\t\t\t\t\t\tjs.Syntax.code(\"continue\");\n\t\t\t\t\tif (str.length != 2)\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\n\t\t\t\t\tjs.Syntax.code(\"}\");\n\t\t\t\t\ts = s.substring(1);\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\t\treturn str;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn \"<function>\";\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn o;\n\t\t\t\tdefault:\n\t\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\n\t\tif (cc == null)\n\t\t\treturn false;\n\t\tif (cc == cl)\n\t\t\treturn true;\n\t\tvar intf:Dynamic = cc.__interfaces__;\n\t\tif (intf != null\n\t\t\t// ES6 classes inherit statics, so we want to avoid accessing inherited `__interfaces__`\n\t\t\t#if (js_es >= 6) && (cc.__super__ == null || cc.__super__.__interfaces__ != intf) #end\n\t\t) {\n\t\t\tfor (i in 0...intf.length) {\n\t\t\t\tvar i:Dynamic = intf[i];\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__, cl);\n\t}\n\n\t@:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\n\t\tif (cl == null)\n\t\t\treturn false;\n\t\tswitch (cl) {\n\t\t\tcase Int:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\t\tcase Float:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\t\tcase Bool:\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\t\tcase String:\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\t\tcase Array:\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\t\tcase Dynamic:\n\t\t\t\treturn o != null;\n\t\t\tdefault:\n\t\t\t\tif (o != null) {\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// do not use isClass/isEnum here\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\treturn o.__enum__ == cl;\n\t\t\t\t#else\n\t\t\t\treturn untyped __feature__(\n\t\t\t\t\t\"has_enum\",\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\t#end\n\t\t}\n\t}\n\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\n\t}\n\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\n\t\treturn __interfLoop(getClass(o), iface);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\n\t\tif (o == null || __instanceof(o, t))\n\t\t\treturn o;\n\t\telse\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n}\n","package thx;\n\nimport haxe.PosInfos;\nimport haxe.CallStack;\nimport thx.error.ErrorWrapper;\n\n/**\nDefines a generic Error type. When the target platform is JS, `Error` extends the native\n`js.lib.Error` type.\n**/\nclass Error #if js extends js.lib.Error #end {\n/**\nIt creates an instance of Error from any value.\n\nIf `err` is already an instance of `Error`, it is returned and nothing is created.\n**/\n  public static function fromDynamic(err: Dynamic, ?pos: PosInfos): Error {\n    if(Std.is(err, Error))\n      return cast err;\n    return new ErrorWrapper(\"\"+err, err, null, pos);\n  }\n\n#if !js\n/**\nThe text message associated with the error.\n**/\n  public var message(default, null): String;\n#end\n/**\nThe location in code where the error has been instantiated.\n**/\n  public var pos(default, null): PosInfos;\n\n/**\nThe collected error stack.\n**/\n  public var stackItems(default, null): Array<StackItem>;\n\n/**\nThe `Error` constructor only requires a string message. `stack` and `pos` are automatically\npopulated, but can be provided if preferred.\n**/\n  public function new(message: String, ?stack: Array<StackItem>, ?pos: PosInfos) {\n#if js\n    super(message);\n#end\n    this.message = message;\n\n    if(null == stack) {\n      stack = try CallStack.exceptionStack() catch(e: Dynamic) [];\n      if(stack.length == 0)\n        stack = try CallStack.callStack() catch(e: Dynamic) [];\n    }\n    this.stackItems = stack;\n    this.pos = pos;\n  }\n\n  public function toString()\n    return message + \"\\nfrom: \" + getPosition() + \"\\n\\n\" + stackToString();\n\n  public function getPosition()\n    return pos.className + \".\" + pos.methodName + \"() at \" + pos.lineNumber;\n\n  public function stackToString()\n    return CallStack.toString(stackItems);\n}\n","package thx;\n\n/**\n`Timer` provides several meaning to delay the execution of code. At the moment it is only\nimplemented for platforms that have a native concept of Timer like Swf and JavaScript or c++/Neko\nwith OpenFL or NME.\n\nAll of the Timer methods return a function with signature Void -> Void that can be used to cancel\nthe timer.\n\n```haxe\n// set the execution delayed by 200ms\nvar cancel = Timer.delay(doSomethingLater, 200);\n\n// cancel immediately (doSomethingLater will never be executed)\ncancel();\n```\n\nNote that calling the cancel function multiple times have no effect after the first execution.\n**/\nclass Timer {\n/**\nCreates a function that delays the execution of `callback` by `delayms` every time it is\ninvoked. If `leading` is set to true, a first execution is guaranteed to happen as soon\nas the returnd function is invoked.\n**/\n  public static function debounce(callback : Void -> Void, delayms : Int, leading = false) {\n    var cancel = Functions.noop;\n    function poll() {\n      cancel();\n      cancel = Timer.delay(callback, delayms);\n    }\n    return function() {\n        if(leading) {\n          leading = false;\n          callback();\n        }\n        poll();\n    }\n  }\n\n/**\nThe returned function executes `callback` at most once every `delayms` regardless of\nhow many times it is invoked in that timespance. Setting `leading` to true ensures\nthat the callback is invoked at the beginning of the cycle.\n**/\n  public static function throttle(callback : Void -> Void, delayms : Int, leading = false) {\n    var waiting = false;\n    function poll() {\n      waiting = true;\n      Timer.delay(callback, delayms);\n    }\n    return function() {\n        if(leading) {\n          leading = false;\n          callback();\n          return;\n        }\n        if(waiting)\n          return;\n        poll();\n    };\n  }\n\n// IMPLEMENTATIONS\n\n#if !(js || flash)\n  static var timers = new Map<Int, haxe.Timer>();\n  static var _id = 0;\n#end\n\n/**\n`Timer.repeat` continues to invoke `callback` until it is cancelled using the returned\ncancel function.\n**/\n  public static function repeat(callback : Void -> Void, delayms : Int) : Void -> Void {\n#if js\n    return clear.bind(untyped __js__('setInterval')(callback, delayms));\n#elseif flash9\n    return clear.bind(untyped __global__[\"flash.utils.setInterval\"](callback, delayms));\n#elseif flash\n    return clear.bind(untyped _global[\"setInterval\"](callback, delayms));\n// #elseif java\n//     var executorService = java.util.concurrent.Executors.newSingleThreadScheduledExecutor();\n//     var handler = executorService.scheduleAtFixedRate(new TimerTask(callback), haxe.Int64.ofInt(delayms), haxe.Int64.ofInt(delayms), java.util.concurrent.TimeUnit.MILLISECONDS);\n//     return handler.cancel.bind(true);\n#elseif !lime\n    return throw \"platform does not support delays (Timer.repeat)\";\n#else\n    var id = _id++,\n        timer = new haxe.Timer(delayms);\n    timer.run = callback;\n    timers.set(id, timer);\n    return clear.bind(id);\n#end\n  }\n\n/**\n`Timer.delay` invokes `callback` after `delayms` milliseconds. The scheduling can be\ncanelled using the returned cancel function.\n**/\n  public static function delay(callback : Void -> Void, delayms : Int) : Void -> Void {\n#if js\n    return clear.bind(untyped __js__('setTimeout')(callback, delayms));\n#elseif flash9\n    return clear.bind(untyped __global__[\"flash.utils.setTimeout\"](callback, delayms));\n#elseif flash\n    return clear.bind(untyped _global[\"setTimeout\"](callback, delayms));\n// #elseif java\n//     var executorService = java.util.concurrent.Executors.newSingleThreadScheduledExecutor();\n//     var handler = executorService.schedule(new TimerTask(callback), haxe.Int64.ofInt(delayms), java.util.concurrent.TimeUnit.MILLISECONDS);\n//     return handler.cancel.bind(true);\n#elseif !lime\n    return throw \"platform does not support delays (Timer.delay)\";\n#else\n    var id = _id++,\n        timer = haxe.Timer.delay(function() {\n          callback();\n          clear(id);\n        }, delayms);\n    timers.set(id, timer);\n    return clear.bind(id);\n#end\n  }\n\n/**\nInvokes `callback` at every frame using native implementation where available. A delta time\nin milliseconds is passed since the latest time callback was invoked.\n**/\n  public static function frame(callback : Float -> Void) {\n#if js\n    var cancelled = false,\n        f = Functions.noop,\n        current = time(),\n        next;\n    f = function() {\n          if(cancelled) return;\n          next = time();\n          callback(next - current);\n          current = next;\n          untyped __js__(\"requestAnimationFrame\")(f);\n        };\n\n    untyped __js__(\"requestAnimationFrame\")(f);\n    return function() cancelled = true;\n#elseif openfl\n    var current = time(),\n        next,\n        listener = function(_) {\n          next = time();\n          callback(next - current);\n          current = next;\n        };\n    openfl.Lib.current.addEventListener(openfl.events.Event.ENTER_FRAME, listener);\n    return function()\n      openfl.Lib.current.removeEventListener(openfl.events.Event.ENTER_FRAME, listener);\n#elseif flash9\n    var current = time(),\n        next,\n        listener = function(_) {\n          next = time();\n          callback(next - current);\n          current = next;\n        };\n    flash.Lib.current.addEventListener(flash.events.Event.ENTER_FRAME, listener);\n    return function()\n      flash.Lib.current.removeEventListener(flash.events.Event.ENTER_FRAME, listener);\n#else\n    var current = time(),\n        next,\n        listener = function() {\n          next = time();\n          callback(next - current);\n          current = next;\n        };\n    return repeat(listener, FRAME_RATE);\n#end\n  }\n\n/**\nDelays `callback` untile the next frame using native implementation where available.\n**/\n  public static function nextFrame(callback : Void -> Void) {\n#if js\n    var id = untyped __js__(\"requestAnimationFrame\")(callback);\n    return function() untyped __js__(\"cancelAnimationFrame\")(id);\n#elseif openfl\n    var listener = null,\n        cancel = function() openfl.Lib.current.removeEventListener(openfl.events.Event.ENTER_FRAME, listener);\n    listener = function(_) {\n      cancel();\n      callback();\n    };\n    openfl.Lib.current.addEventListener(openfl.events.Event.ENTER_FRAME, listener);\n    return cancel;\n#elseif flash9\n    var listener = null,\n        cancel = function() flash.Lib.current.removeEventListener(flash.events.Event.ENTER_FRAME, listener);\n    listener = function(_) {\n      cancel();\n      callback();\n    };\n    flash.Lib.current.addEventListener(flash.events.Event.ENTER_FRAME, listener);\n    return cancel;\n#else\n  return delay(callback, FRAME_RATE);\n#end\n  }\n\n  static var FRAME_RATE = Math.round(1000 / 60);\n\n/**\n`Timer.immediate` works essentially like `Timer.delay` with the exception that the delay\nwill be the shortest allowed by the platform. How short the delay depends a lot on\nthe target platform.\n**/\n  public static function immediate(callback : Void -> Void) : Void -> Void\n#if js\n    return clear.bind(untyped __js__('setImmediate')(callback));\n#elseif java\n    // not sure why this is needed\n    return delay(callback, 1);\n#else\n    return delay(callback, 0);\n#end\n\n  static #if js inline #end function clear(id) : Void {\n#if js\n    return untyped __js__('clearTimeout')(id);\n#elseif flash9\n    return untyped __global__[\"flash.utils.clearTimeout\"](id);\n#elseif flash\n    return untyped _global[\"clearTimeout\"](id);\n#elseif !lime\n    return throw \"platform does not support delays (Timer.clear)\";\n#else\n    var timer = timers.get(id);\n    if(null != timer) {\n      timers.remove(id);\n      timer.stop();\n    }\n#end\n  }\n\n/**\nReturns a time value in milliseconds. Where supported, the decimal value represents microseconds.\n\nNote that the initial value might change from platform to platform so only delta measurements make sense.\n**/\n  inline public static function time() : Float\n#if js\n    return untyped __js__(\"performance\").now();\n#elseif flash\n    return flash.Lib.getTimer();\n#elseif (cpp || neko || eval)\n    return haxe.Timer.stamp() * 1000.0;\n#elseif cs\n    return (cs.system.Environment.TickCount : Float);\n#elseif java\n    return cast(java.lang.System.nanoTime(), Float) / 1000000.0;\n#elseif php\n    return untyped __php__('microtime(true) * 1000.0');\n#elseif python\n    return python.lib.Time.clock() * 1000;\n#else\n    return throw 'Timer.time() is not implemented in this target';\n#end\n\n  static var _resolution : Null<Float>;\n  public static function resolution() : Float {\n    if(null != _resolution)\n      return _resolution;\n    var start = time(),\n        end, loop = 0.0;\n    do {\n      loop++;\n      end = Timer.time();\n    } while(end - start == 0);\n    return _resolution = end - start;\n  }\n\n#if js\n  static function __init__() untyped {\n    // Polyfills\n    // SCOPE\n    var scope : Dynamic = __js__('(\"undefined\" !== typeof window && window) || (\"undefined\" !== typeof global && global) || Function(\"return this\")()');\n\n    // setImmediate\n    if(!scope.setImmediate)\n      scope.setImmediate = function(callback) scope.setTimeout(callback, 0);\n\n    // rAF\n    // based on Paul Irish code: http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n    var lastTime = 0,\n        vendors = ['webkit', 'moz'],\n        x = 0;\n\n    while(x < vendors.length && !scope.requestAnimationFrame) {\n      scope.requestAnimationFrame = scope[vendors[x]+'RequestAnimationFrame'];\n      scope.cancelAnimationFrame = scope[vendors[x]+'CancelAnimationFrame'] || scope[vendors[x]+'CancelRequestAnimationFrame'];\n      x++;\n    }\n\n    if (!scope.requestAnimationFrame)\n      scope.requestAnimationFrame = function(callback) {\n        var currTime = Date.now().getTime(),\n            timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n            id = scope.setTimeout(function() callback(currTime + timeToCall), timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n      };\n\n    if (!scope.cancelAnimationFrame)\n      scope.cancelAnimationFrame = function(id) scope.clearTimeout(id);\n\n    // performance.now /  High Resolution Timer\n    if(__js__(\"typeof\")(scope.performance) == \"undefined\")\n      scope.performance = {};\n\n    if(__js__(\"typeof\")(scope.performance.now) == \"undefined\") {\n      var nowOffset = Date.now().getTime();\n\n      if (scope.performance.timing && scope.performance.timing.navigationStart)\n        nowOffset = scope.performance.timing.navigationStart;\n\n      scope.performance.now = function now()\n        return Date.now() - nowOffset;\n    }\n  }\n#end\n}\n\n#if java\n@:nativeGen private class TimerTask extends java.util.TimerTask {\n  var callback : Void -> Void;\n  public function new(callback : Void -> Void) : Void {\n    super();\n    this.callback = callback;\n  }\n\n  @:overload override public function run()\n    callback();\n}\n#end\n","package thx.error;\n\nimport haxe.PosInfos;\nimport haxe.CallStack;\n\n/**\nAn error that keeps a reference to an internal error.\n\nThe internal error is stored as Dynamic to keep its usage flexible.\n*/\nclass ErrorWrapper extends thx.Error {\n  public var innerError : Dynamic;\n  public function new(message : String, innerError : Dynamic, ?stack : Array<StackItem>, ?pos : PosInfos) {\n    super(message, stack, pos);\n\n    this.innerError = innerError;\n  }\n}\n","package thx.promise;\n\nimport haxe.ds.Option;\nusing thx.Arrays;\nimport thx.Error;\nimport thx.Nil;\nusing thx.Options;\nimport thx.Tuple;\n\nclass Future<T> {\n  public static function sequence<T>(arr : Array<Future<T>>) : Future<Array<T>>\n    return Future.create(function(callback : Array<T> -> Void) {\n        var acc = [];\n        function poll(index : Int) {\n          if(index == arr.length)\n            return callback(acc);\n          arr[index]\n            .then(function(v) {\n              acc[index] = v;\n              poll(index+1);\n            });\n        }\n        poll(0);\n      });\n\n#if java // seriously?\npublic static function afterAll<T>(arr : Array<Future<T>>) : Future<Nil>\n  return Future.create(function(callback : Nil -> Void) {\n      function poll(index : Int) {\n        if(index == arr.length)\n          return callback(Nil.nil);\n        arr[index]\n          .then(function(_) {\n            poll(index+1);\n          });\n      }\n      poll(0);\n    });\n#else\n  public static function afterAll(arr : Array<Future<Dynamic>>) : Future<Nil>\n    return sequence(arr).nil();\n#end\n\n  @:deprecated('Future.all is deprecated, use Future.sequence instead')\n  public static function all<T>(arr : Array<Future<T>>) : Future<Array<T>>\n    return sequence(arr);\n\n  public static function create<T>(handler : (T -> Void) -> Void) : Future<T> {\n    var future = new Future<T>();\n    handler(future.setState);\n    return future;\n  }\n\n  inline public static function flatten<T>(future : Future<Future<T>>) : Future<T>\n    return Future.create(function(callback) {\n      future.then(function(future) future.then(callback));\n    });\n\n  public static function value<T>(v : T)\n    return create(function(callback) callback(v));\n\n  var handlers : Array<T -> Void>;\n  public var state(default, null) : Option<T>;\n  private function new() {\n    handlers = [];\n    state = None;\n  }\n\n#if (js || flash)\n  inline public function delay(?delayms : Int) {\n    if(null == delayms)\n      return flatMap(function(v) return Timer.immediateValue(v));\n    else\n      return flatMap(function(v) return Timer.delayValue(v, delayms));\n  }\n#end\n\n  inline public function hasValue()\n    return state.toBool();\n\n  public function map<TOut>(handler : T -> TOut) : Future<TOut>\n    return Future.create(function(callback)\n      then(function(v) callback(handler(v))));\n\n  public function mapAsync<TOut>(handler : T -> (TOut -> Void) -> Void) : Future<TOut>\n    return Future.create(function(callback)\n      then(function(result : T )\n        handler(result, callback)));\n\n  public function mapPromise<TOut>(handler : T -> Promise<TOut>) : Promise<TOut>\n    return Promise.create(function(resolve, reject)\n      then(function(result : T)\n        handler(result)\n          .success(resolve)\n          .failure(reject)));\n\n  public function nil() : Future<Nil>\n    return map(function(_) return Nil.nil);\n\n  @:deprecated(\"Future.mapFuture is deprecated, use Future.flatMap\")\n  inline public function mapFuture<TOut>(handler : T -> Future<TOut>) : Future<TOut>\n    return flatMap(handler);\n\n  public function flatMap<TOut>(handler : T -> Future<TOut>) : Future<TOut>\n    return Future.create(function(callback)\n      then(function(v) handler(v).then(callback)));\n\n  public function then(handler : T -> Void): Future<T> {\n    handlers.push(handler);\n    update();\n    return this;\n  }\n\n  public function toString() return 'Future';\n\n  function setState(newstate : T) {\n    switch state {\n      case None:\n        state = Some(newstate);\n      case Some(r):\n        throw new Error('future was already \"$r\", can\\'t apply the new state \"$newstate\"');\n    }\n    update();\n    return this;\n  }\n\n  function update() {\n    switch state {\n      case None:\n      case Some(result): {\n        var index = -1;\n        while(++index < handlers.length) {\n          var handler = handlers[index];\n          handler(result);\n        }\n        handlers = [];\n      }\n    };\n  }\n}\n\nclass Futures {\n  public static function join<T1,T2>(p1 : Future<T1>, p2 : Future<T2>) : Future<Tuple2<T1,T2>> {\n    return Future.create(function(callback) {\n      var counter = 0,\n          v1 : Null<T1> = null,\n          v2 : Null<T2> = null;\n\n      function complete() {\n        if(counter < 2)\n          return;\n        callback(new Tuple2(v1, v2));\n      }\n\n      p1.then(function(v) {\n        counter++;\n        v1 = v;\n        complete();\n      });\n\n      p2.then(function(v) {\n        counter++;\n        v2 = v;\n        complete();\n      });\n    });\n  }\n\n  public static function log<T>(future : Future<T>, ?prefix : String = '')\n    return future.then(\n      function(r) trace('$prefix VALUE: $r')\n    );\n}\n\nclass FutureTuple6 {\n  public static function mapTuple<T1,T2,T3,T4,T5,T6,TOut>(future : Future<Tuple6<T1,T2,T3,T4,T5,T6>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> TOut) : Future<TOut>\n    return future.map(function(t)\n      return callback(t._0, t._1, t._2, t._3, t._4, t._5)\n    );\n\n  public static function mapTupleAsync<T1,T2,T3,T4,T5,T6,TOut>(future : Future<Tuple6<T1,T2,T3,T4,T5,T6>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, t._2, t._3, t._4, t._5, cb));\n\n  public static function mapTupleFuture<T1,T2,T3,T4,T5,T6,TOut>(future : Future<Tuple6<T1,T2,T3,T4,T5,T6>>, callback : T1 -> T2 -> T3  -> T4 -> T5 -> T6 -> Future<TOut>) : Future<TOut>\n    return future.flatMap(function(t) return callback(t._0, t._1, t._2, t._3, t._4, t._5));\n\n  public static function tuple<T1,T2,T3,T4,T5,T6>(future : Future<Tuple6<T1,T2,T3,T4,T5,T6>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> Void)\n    return future.then(function(t) callback(t._0, t._1, t._2, t._3, t._4, t._5));\n}\n\nclass FutureTuple5 {\n  public static function join<T1,T2,T3,T4,T5,T6>(p1 : Future<Tuple5<T1,T2,T3,T4,T5>>, p2 : Future<T6>) : Future<Tuple6<T1,T2,T3,T4,T5,T6>>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(\n          function(t) callback(t._0.with(t._1))));\n\n  public static function mapTuple<T1,T2,T3,T4,T5,TOut>(future : Future<Tuple5<T1,T2,T3,T4,T5>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> TOut) : Future<TOut>\n    return future.map(function(t)\n      return callback(t._0, t._1, t._2, t._3, t._4)\n    );\n\n  public static function mapTupleAsync<T1,T2,T3,T4,T5,TOut>(future : Future<Tuple5<T1,T2,T3,T4,T5>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, t._2, t._3, t._4, cb));\n\n  public static function mapTupleFuture<T1,T2,T3,T4,T5,TOut>(future : Future<Tuple5<T1,T2,T3,T4,T5>>, callback : T1 -> T2 -> T3  -> T4 -> T5 -> Future<TOut>) : Future<TOut>\n    return future.flatMap(function(t) return callback(t._0, t._1, t._2, t._3, t._4));\n\n  public static function tuple<T1,T2,T3,T4,T5>(future : Future<Tuple5<T1,T2,T3,T4,T5>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> Void)\n    return future.then(function(t) callback(t._0, t._1, t._2, t._3, t._4));\n}\n\nclass FutureTuple4 {\n  public static function join<T1,T2,T3,T4,T5>(p1 : Future<Tuple4<T1,T2,T3,T4>>, p2 : Future<T5>) : Future<Tuple5<T1,T2,T3,T4,T5>>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(\n          function(t) callback(t._0.with(t._1))));\n\n  public static function mapTuple<T1,T2,T3,T4,TOut>(future : Future<Tuple4<T1,T2,T3,T4>>, callback : T1 -> T2 -> T3 -> T4 -> TOut) : Future<TOut>\n    return future.map(function(t)\n      return callback(t._0, t._1, t._2, t._3)\n    );\n\n  public static function mapTupleAsync<T1,T2,T3,T4,TOut>(future : Future<Tuple4<T1,T2,T3,T4>>, callback : T1 -> T2 -> T3 -> T4 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, t._2, t._3, cb));\n\n  public static function mapTupleFuture<T1,T2,T3,T4,TOut>(future : Future<Tuple4<T1,T2,T3,T4>>, callback : T1 -> T2 -> T3  -> T4 -> Future<TOut>) : Future<TOut>\n    return future.flatMap(function(t) return callback(t._0, t._1, t._2, t._3));\n\n  public static function tuple<T1,T2,T3,T4>(future : Future<Tuple4<T1,T2,T3,T4>>, callback : T1 -> T2 -> T3 -> T4 -> Void)\n    return future.then(function(t) callback(t._0, t._1, t._2, t._3));\n}\n\nclass FutureTuple3 {\n  public static function join<T1,T2,T3,T4>(p1 : Future<Tuple3<T1,T2,T3>>, p2 : Future<T4>) : Future<Tuple4<T1,T2,T3,T4>>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(\n          function(t) callback(t._0.with(t._1))));\n\n  public static function mapTuple<T1,T2,T3,TOut>(future : Future<Tuple3<T1,T2,T3>>, callback : T1 -> T2 -> T3 -> TOut) : Future<TOut>\n    return future.map(function(t)\n      return callback(t._0, t._1, t._2)\n    );\n\n  public static function mapTupleAsync<T1,T2,T3,TOut>(future : Future<Tuple3<T1,T2,T3>>, callback : T1 -> T2 -> T3 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, t._2, cb));\n\n  public static function mapTupleFuture<T1,T2,T3,TOut>(future : Future<Tuple3<T1,T2,T3>>, callback : T1 -> T2 -> T3  -> Future<TOut>) : Future<TOut>\n    return future.flatMap(function(t) return callback(t._0, t._1, t._2));\n\n  public static function tuple<T1,T2,T3>(future : Future<Tuple3<T1,T2,T3>>, callback : T1 -> T2 -> T3 -> Void)\n    return future.then(function(t) callback(t._0, t._1, t._2));\n}\n\nclass FutureTuple2 {\n  public static function join<T1,T2,T3>(p1 : Future<Tuple2<T1,T2>>, p2 : Future<T3>) : Future<Tuple3<T1,T2,T3>>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(function(t) callback(t._0.with(t._1))));\n\n  public static function mapTuple<T1,T2,TOut>(future : Future<Tuple2<T1,T2>>, callback : T1 -> T2 -> TOut) : Future<TOut>\n    return future.map(function(t) return callback(t._0, t._1));\n\n  public static function mapTupleAsync<T1,T2,TOut>(future : Future<Tuple2<T1,T2>>, callback : T1 -> T2 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, cb));\n\n  public static function mapTupleFuture<T1,T2,TOut>(future : Future<Tuple2<T1,T2>>, callback : T1 -> T2 -> Future<TOut>) : Future<TOut>\n    return future.flatMap(function(t) return callback(t._0, t._1));\n\n  public static function tuple<T1,T2>(future : Future<Tuple2<T1,T2>>, callback : T1 -> T2 -> Void)\n    return future.then(function(t) callback(t._0, t._1));\n}\n\nclass FutureNil {\n  public static function join<T2>(p1 : Future<Nil>, p2 : Future<T2>) : Future<T2>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(function(t) callback(t._1)));\n\n  public static function nil(p : Future<Dynamic>) : Future<Nil>\n    return Future.create(function(callback : Nil -> Void)\n      p.then(function(_) callback(Nil.nil)));\n}\n","package thx.promise;\n\nimport haxe.ds.Option;\n\nimport thx.Either;\nimport thx.Error;\nimport thx.Nil;\nimport thx.Result;\nimport thx.Tuple;\nimport thx.fp.Functions.const;\n\nusing thx.Arrays;\nusing thx.Functions;\nusing thx.Options;\n\ntypedef PromiseValue<T> = Result<T, Error>;\n\n@:forward(hasValue, mapAsync, state, then)\nabstract Promise<T>(Future<Result<T, Error>>) to Future<Result<T, Error>> {\n  inline private function new(future: Future<Result<T, Error>>)\n    this = future;\n\n  public static function fromFuture<T>(future : Future<T>) : Promise<T>\n    return new Promise(future.map(function(v) return (Right(v) : PromiseValue<T>)));\n\n  // Note: this can be a static var again, when the issue #19 with promise reuse is fixed\n  //public static var nil(default, null) : Promise<Nil> = Promise.value(Nil.nil);\n  public static var nil(get, null) : Promise<Nil>;\n  static function get_nil() : Promise<Nil> return Promise.value(Nil.nil);\n\n  @:deprecated(\"Use Promise.sequence instead; since Promise construction is eager there is no difference between the two.\")\n  public static function all<T>(arr : Array<Promise<T>>) : Promise<Array<T>> {\n    return if (arr.length == 0) Promise.value([])\n    else Promise.create(\n      function(resolve, reject) {\n        var results  = [],\n            counter  = 0,\n            hasError = false;\n\n        // For each element of the array, mutate the results completion. When\n        // all results have been included, or an error is encountered, resolve\n        // the resulting promise.\n        for (i in 0...arr.length) {\n          arr[i].either(\n            function(v) {\n              if (!hasError) {\n                results[i] = v;\n                counter++;\n\n                if(counter == arr.length) resolve(results);\n              }\n            },\n            function(err) {\n              if (!hasError) {\n                hasError = true;\n                reject(err);\n              }\n            }\n          );\n        }\n      }\n    );\n  }\n\n  public static function afterAll(arr : Array<Promise<Dynamic>>) : Promise<Nil>\n    return sequence(arr).map(const(Nil.nil));\n\n  public static function sequence<T>(arr : Array<Promise<T>>) : Promise<Array<T>> {\n    return arr.reduce(\n      function(acc: Promise<Array<T>>, p: Promise<T>) return acc.flatMap(\n        function(arr: Array<T>) return p.map(function(t) return arr.concat([t]))\n      ),\n      Promise.value([])\n    );\n  }\n\n  @:deprecated(\"Use Promise.sequence instead.\")\n  public static function allSequence<T>(arr : Array<Promise<T>>) : Promise<Array<T>>\n    return sequence(arr);\n\n  public static function create<T>(callback : (T -> Void) -> (Error -> Void) -> Void) : Promise<T>\n    return new Promise(\n      Future.create(function(cb : PromiseValue<T> -> Void) {\n        try {\n          callback(\n            function(v : T)     cb((Right(v) : PromiseValue<T>)),\n            function(e : Error) cb((Left(e) : PromiseValue<T>))\n          );\n        } catch(e : Dynamic) {\n          cb((Left(Error.fromDynamic(e)) : PromiseValue<T>));\n        }\n      })\n    );\n\n  public static function createUnsafe<T>(callback : (T -> Void) -> (Error -> Void) -> Void) : Promise<T>\n    return new Promise(\n      Future.create(function(cb : PromiseValue<T> -> Void) {\n        callback(\n          function(v : T)     cb((Right(v) : PromiseValue<T>)),\n          function(e : Error) cb((Left(e) : PromiseValue<T>))\n        );\n      })\n    );\n\n  public static function createFulfill<T>(callback : (PromiseValue<T> -> Void) -> Void) : Promise<T>\n    return new Promise(Future.create(function(cb) {\n      try callback(cb) catch(e : Dynamic) cb(Left(Error.fromDynamic(e)));\n    }));\n\n  public static function fail<T>(message : String, ?pos : haxe.PosInfos) : Promise<T>\n    return error(new thx.Error(message, pos));\n\n  public static function error<T>(err : Error) : Promise<T>\n    return Promise.create(function(_, reject) reject(err));\n\n  public static function value<T>(v : T) : Promise<T>\n    return Promise.create(function(resolve, _) resolve(v));\n\n  public function always(handler : Void -> Void) : Promise<T>\n    return new Promise(\n      Future.create(function(cb : PromiseValue<T> -> Void) {\n        this.then(function(v) {\n          try {\n            handler();\n            cb(v);\n          } catch(e : Dynamic) {\n            cb(Left(Error.fromDynamic(e)));\n          }\n        });\n      })\n    );\n\n  public function either(success : T -> Void, failure : Error -> Void) : Promise<T>\n    return Promise.createUnsafe(function(resolve : T -> Void, reject : Error -> Void) {\n      this.then(function(r) {\n        try {\n          switch r {\n            case Right(v):\n              success(v);\n              resolve(v);\n            case Left(e):\n              failure(e);\n              reject(e);\n          }\n        } catch(e : Dynamic) {\n          reject(Error.fromDynamic(e));\n        }\n      });\n    });\n\n#if (js || flash)\n  public function delay(?delayms : Int) : Promise<T>\n    return new Promise(this.delay(delayms));\n#end\n\n  public function isFailure() : Bool\n    return switch this.state {\n      case None, Some(Right(_)): false;\n      case _: true;\n    };\n\n  public function isResolved() : Bool\n    return switch this.state {\n      case None, Some(Left(_)): false;\n      case _: true;\n    };\n\n  public function isPending() : Bool\n    return switch this.state {\n      case Some(_): false;\n      case None: true;\n    };\n\n  public function failure(failure : Error -> Void) : Promise<T>\n    return either(function(_){}, failure);\n\n  inline public function mapAlways<TOut>(handler : Void -> TOut) : Promise<TOut>\n    return map(function(_) return handler());\n\n  inline public function mapAlwaysAsyncFuture<TOut>(handler : (TOut -> Void) -> Void) : Future<TOut>\n    return this.mapAsync(function(_, cb) return handler(cb));\n\n  inline public function mapAlwaysFuture<TOut>(handler : Void -> Future<TOut>) : Future<TOut>\n    return this.flatMap(function(_) return handler());\n\n  public function mapEither<TOut>(success : T -> TOut, failure : Error -> TOut) : Promise<TOut>\n    return flatMapEither(\n      function(v) return Promise.value(success(v)),\n      function(e) return Promise.value(failure(e))\n    );\n\n  public function mapEitherFuture<TOut>(success : T -> TOut, failure : Error -> TOut) : Future<TOut>\n    return flatMapEitherFuture(\n      function(v) return Future.value(success(v)),\n      function(e) return Future.value(failure(e))\n    );\n\n  public function flatMapEitherFuture<TOut>(success : T -> Future<TOut>, failure : Error -> Future<TOut>) : Future<TOut>\n    return this.flatMap(function(result : Result<T, Error>)\n      return switch result {\n        case Right(v): success(v);\n        case Left(e):  failure(e);\n      });\n\n  public function flatMapEither<TOut>(success : T -> Promise<TOut>, failure : Error -> Promise<TOut>) : Promise<TOut> {\n    return Promise.createUnsafe(function(resolve : TOut -> Void, reject : Error -> Void) {\n      this.then(function(result : Result<T, Error>) : Void {\n        switch result {\n          case Right(v): try success(v).either(resolve, reject) catch(e : Dynamic) reject(Error.fromDynamic(e));\n          case Left(e):  try failure(e).either(resolve, reject) catch(e : Dynamic) reject(Error.fromDynamic(e));\n        }\n      });\n    });\n  }\n\n  @:deprecated(\"Promise.mapFailure is deprecated, use Promise.recoverAsFuture instead\")\n  public function mapFailure(failure : Error -> T) : Future<T>\n    return mapEitherFuture(function(v : T) return v, failure);\n\n  @:deprecated(\"Promise.mapFailureFuture is deprecated, use Promise.recover instead\")\n  public function mapFailureFuture(failure : Error -> Future<T>) : Future<T>\n    return flatMapEitherFuture(function(v : T) return Future.value(v), failure);\n\n  @:deprecated(\"Promise.mapFailurePromise is deprecated, use Promise.recover instead\")\n  public function mapFailurePromise(failure : Error -> Promise<T>) : Promise<T>\n    return recover(failure);\n\n  public function recover(failure : Error -> Promise<T>) : Promise<T>\n    return flatMapEither(function(v) return Promise.value(v), failure);\n\n  public function recoverAsFuture(failure : Error -> T) : Future<T>\n    return mapEitherFuture(function(v : T) return v, failure);\n\n  public function map<U>(success : T -> U) : Promise<U>\n    return flatMap(function(v) return Promise.value(success(v)));\n\n  public function ap<U>(pf: Promise<T -> U>): Promise<U>\n    return flatMap(function(t) return pf.map.fn(_(t)));\n\n  @:deprecated(\"mapSuccess is deprecated. Use map instead\")\n  inline public function mapSuccess<TOut>(success : T -> TOut) : Promise<TOut>\n    return map(success);\n\n  inline public function flatMap<TOut>(success : T -> Promise<TOut>) : Promise<TOut>\n    return flatMapEither(success, function(err) return Promise.error(err));\n\n  inline public function append<TOut>(success : Void -> Promise<TOut>) : Promise<TOut>\n    return flatMap(function(_) return success());\n\n  @:op(A >> B)\n  inline public function andThen<B>(next: Void -> Promise<B>): Promise<B>\n    return flatMap(function(_) return next());\n\n  /**\n   * Performs an additional effect with the result of this promise, and\n   * when it completes ignore the resulting value and instead return\n   * the result of this promise. This is similar to success(...)\n   * except that the additional side effect expressed in the result of `f`\n   * must complete before computation can proceed.\n   */\n  inline public function foreachM<U>(f: T -> Promise<U>): Promise<T>\n    return flatMap(function(t) return f(t).map(const(t)));\n\n  @:deprecated(\"Promise.mapSuccessPromise is deprecated. Use Promise.flatMap instead\")\n  public function mapSuccessPromise<TOut>(success : T -> Promise<TOut>) : Promise<TOut>\n    return flatMap(success);\n\n  @:deprecated(\"Promise.mapNull is deprecated. Use Promise.recoverNull instead\")\n  public function mapNull(handler : Void -> Promise<Null<T>>) : Promise<T>\n    return recoverNull(handler);\n\n  public function recoverNull(handler : Void -> Promise<Null<T>>) : Promise<T>\n    return flatMap(function(v : Null<T>) {\n      if(null == v)\n        return handler();\n      else\n        return Promise.value(v);\n    });\n\n  public function success(success : T -> Void) : Promise<T>\n    return either(success, function(_){});\n\n  public function throwFailure() : Promise<T>\n    return new Promise(this.then(function(r) switch r {\n      case Left(err): throw err;\n      case _: // do nothing\n    }));\n\n  public function toString() return 'Promise';\n\n  inline public function toFuture() : Future<PromiseValue<T>> return this;\n}\n\nclass Promises {\n  public static function par<T1,T2,T3>(f: T1 -> T2 -> T3, p1 : Promise<T1>, p2 : Promise<T2>) : Promise<T3> {\n    return Promise.create(function(resolve, reject) {\n      var hasError = false,\n          counter = 0,\n          v1 : Null<T1> = null,\n          v2 : Null<T2> = null;\n\n      function complete() {\n        if(counter < 2)\n          return;\n        resolve(f(v1, v2));\n      }\n\n      function handleError(error) {\n        if(hasError) return;\n        hasError = true;\n        reject(error);\n      }\n\n      p1.either(function(v) {\n        if(hasError) return;\n        counter++;\n        v1 = v;\n        complete();\n      }, handleError);\n\n      p2.either(function(v) {\n        if(hasError) return;\n        counter++;\n        v2 = v;\n        complete();\n      }, handleError);\n    });\n  }\n\n  public static function par3<T1, T2, T3, T4>(f: T1 -> T2 -> T3 -> T4, p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>) : Promise<T4>\n    return par(function(f, g) return f(g), par(f.curry(), p1, p2), p3);\n\n  public static function par4<T1, T2, T3, T4, T5>(f: T1 -> T2 -> T3 -> T4 -> T5, p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>, p4 : Promise<T4>) : Promise<T5>\n    return par(function(f, g) return f(g), par3(f.curry(), p1, p2, p3), p4);\n\n  public static function par5<T1, T2, T3, T4, T5, T6>(f: T1 -> T2 -> T3 -> T4 -> T5 -> T6, p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>, p4 : Promise<T4>, p5: Promise<T5>):Promise<T6>\n    return par(function(f, g) return f(g), par4(f.curry(), p1, p2, p3, p4), p5);\n\n  public static function par6<T1, T2, T3, T4, T5, T6, T7>(f: T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> T7, p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>, p4 : Promise<T4>, p5: Promise<T5>, p6: Promise<T6>): Promise<T7>\n    return par(function(f, g) return f(g), par5(f.curry(), p1, p2, p3, p4, p5), p6);\n\n  inline public static function join<T1,T2>(p1 : Promise<T1>, p2 : Promise<T2>) : Promise<Tuple2<T1,T2>>\n    return par(Tuple.of, p1, p2);\n\n  // alias for join\n  inline public static function join2<T1,T2>(p1 : Promise<T1>, p2 : Promise<T2>) : Promise<Tuple2<T1,T2>>\n    return join(p1, p2);\n\n  public static function join3<T1, T2, T3>(p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>) : Promise<Tuple3<T1, T2, T3>>\n    return par3(Tuple3.of, p1, p2, p3);\n\n  public static function join4<T1, T2, T3, T4>(p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>, p4 : Promise<T4>) : Promise<Tuple4<T1, T2, T3, T4>>\n    return par4(Tuple4.of, p1, p2, p3, p4);\n\n  public static function join5<T1, T2, T3, T4, T5>(p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>, p4 : Promise<T4>, p5 : Promise<T5>) : Promise<Tuple5<T1, T2, T3, T4, T5>>\n    return par5(Tuple5.of, p1, p2, p3, p4, p5);\n\n  public static function join6<T1, T2, T3, T4, T5, T6>(p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>, p4 : Promise<T4>, p5 : Promise<T5>, p6 : Promise<T6>) : Promise<Tuple6<T1, T2, T3, T4, T5, T6>>\n    return par6(Tuple6.of, p1, p2, p3, p4, p5, p6);\n\n  public static function log<T>(promise : Promise<T>, ?prefix : String = '')\n    return promise.either(\n      function(r) trace('$prefix SUCCESS: $r'),\n      function(e) trace('$prefix ERROR: ${e.toString()}')\n    );\n}\n\nclass PromiseTuple6 {\n  public static function mapTuplePromise<T1,T2,T3,T4,T5,T6,TOut>(promise : Promise<Tuple6<T1,T2,T3,T4,T5,T6>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> Promise<TOut>) : Promise<TOut>\n    return promise.flatMap(function(t)\n      return success(t._0, t._1, t._2, t._3, t._4, t._5)\n    );\n\n  public static function mapTuple<T1,T2,T3,T4,T5,T6,TOut>(promise : Promise<Tuple6<T1,T2,T3,T4,T5,T6>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> TOut) : Promise<TOut>\n    return promise.map(function(t)\n      return success(t._0, t._1, t._2, t._3, t._4, t._5)\n    );\n\n  public static function tuple<T1,T2,T3,T4,T5,T6>(promise : Promise<Tuple6<T1,T2,T3,T4,T5,T6>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2, t._3, t._4, t._5),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple5 {\n  public static function join<T1,T2,T3,T4,T5,T6>(p1 : Promise<Tuple5<T1,T2,T3,T4,T5>>, p2 : Promise<T6>) : Promise<Tuple6<T1,T2,T3,T4,T5,T6>>\n    return Promises.par(function(f: Tuple5<T1,T2,T3,T4,T5>, g: T6) return f.with(g), p1, p2);\n\n  public static function mapTuplePromise<T1,T2,T3,T4,T5,TOut>(promise : Promise<Tuple5<T1,T2,T3,T4,T5>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> Promise<TOut>) : Promise<TOut>\n    return promise.flatMap(function(t)\n      return success(t._0, t._1, t._2, t._3, t._4)\n    );\n\n  public static function mapTuple<T1,T2,T3,T4,T5,TOut>(promise : Promise<Tuple5<T1,T2,T3,T4,T5>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> TOut) : Promise<TOut>\n    return promise.map(function(t)\n      return success(t._0, t._1, t._2, t._3, t._4)\n    );\n\n  public static function tuple<T1,T2,T3,T4,T5>(promise : Promise<Tuple5<T1,T2,T3,T4,T5>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2, t._3, t._4),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple4 {\n  public static function join<T1,T2,T3,T4,T5>(p1 : Promise<Tuple4<T1,T2,T3,T4>>, p2 : Promise<T5>) : Promise<Tuple5<T1,T2,T3,T4,T5>>\n    return Promises.par(function(f: Tuple4<T1,T2,T3,T4>, g: T5) return f.with(g), p1, p2);\n\n  public static function mapTuplePromise<T1,T2,T3,T4,TOut>(promise : Promise<Tuple4<T1,T2,T3,T4>>, success : T1 -> T2 -> T3 -> T4 -> Promise<TOut>) : Promise<TOut>\n    return promise.flatMap(function(t)\n      return success(t._0, t._1, t._2, t._3)\n    );\n\n  public static function mapTuple<T1,T2,T3,T4,TOut>(promise : Promise<Tuple4<T1,T2,T3,T4>>, success : T1 -> T2 -> T3 -> T4 -> TOut) : Promise<TOut>\n    return promise.map(function(t)\n      return success(t._0, t._1, t._2, t._3)\n    );\n\n  public static function tuple<T1,T2,T3,T4>(promise : Promise<Tuple4<T1,T2,T3,T4>>, success : T1 -> T2 -> T3 -> T4 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2, t._3),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple3 {\n  public static function join<T1,T2,T3,T4>(p1 : Promise<Tuple3<T1,T2,T3>>, p2 : Promise<T4>) : Promise<Tuple4<T1,T2,T3,T4>>\n    return Promises.par(function(f: Tuple3<T1, T2, T3>, g: T4) return f.with(g), p1, p2);\n\n  public static function mapTuplePromise<T1,T2,T3,TOut>(promise : Promise<Tuple3<T1,T2,T3>>, success : T1 -> T2 -> T3 -> Promise<TOut>) : Promise<TOut>\n    return promise.flatMap(function(t)\n      return success(t._0, t._1, t._2)\n    );\n\n  public static function mapTuple<T1,T2,T3,TOut>(promise : Promise<Tuple3<T1,T2,T3>>, success : T1 -> T2 -> T3 -> TOut) : Promise<TOut>\n    return promise.map(function(t)\n      return success(t._0, t._1, t._2)\n    );\n\n  public static function tuple<T1,T2,T3>(promise : Promise<Tuple3<T1,T2,T3>>, success : T1 -> T2 -> T3 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple2 {\n  public static function join<T1,T2,T3>(p1 : Promise<Tuple2<T1,T2>>, p2 : Promise<T3>) : Promise<Tuple3<T1,T2,T3>>\n    return Promises.par(function(f: Tuple2<T1, T2>, g: T3) return f.with(g), p1, p2);\n\n  public static function mapTuplePromise<T1,T2,TOut>(promise : Promise<Tuple2<T1,T2>>, success : T1 -> T2 -> Promise<TOut>) : Promise<TOut>\n    return promise.flatMap(function(t)\n      return success(t._0, t._1)\n    );\n\n  public static function mapTuple<T1,T2,TOut>(promise : Promise<Tuple2<T1,T2>>, success : T1 -> T2 -> TOut) : Promise<TOut>\n    return promise.map(function(t)\n      return success(t._0, t._1)\n    );\n\n  public static function tuple<T1,T2>(promise : Promise<Tuple2<T1,T2>>, success : T1 -> T2 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseNil {\n  public static function join<T2>(p1 : Promise<Nil>, p2 : Promise<T2>) : Promise<T2>\n    return Promises.par(function(_, g) return g, p1, p2);\n\n  public static function nil<A>(p : Promise<A>) : Promise<Nil>\n    return p.map(const(Nil.nil));\n}\n\n#if js\nclass PromiseAPlus {\n  public static function promise<T>(p : js.Promise<T>, ?pos : haxe.PosInfos) : Promise<T>\n    return Promise.create(function(resolve, reject) {\n      p.then(resolve, function(e) reject(Error.fromDynamic(e, pos)));\n    });\n\n  public static function aPlus<T>(p : Promise<T>) : js.Promise<T>\n    return new js.Promise(function(resolve, reject) {\n        p.success(resolve).failure(reject);\n      });\n}\n\nclass PromiseAPlusVoid {\n  public static function promise(p : js.Promise<Void>, ?pos : haxe.PosInfos) : Promise<Nil>\n    return Promise.create(function(resolve, reject) {\n      p.then(cast function() resolve(nil), function(e) reject(Error.fromDynamic(e, pos)));\n    });\n\n  public static function aPlus(p : Promise<Void>) : js.Promise<Nil>\n    return new js.Promise(function(resolve, reject) {\n        p.success(cast function() resolve(nil)).failure(reject);\n      });\n}\n#end\n"],
"names":[],
"mappings":"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"
}