{
"version":3,
"file":"example.js",
"sourceRoot":"file:///",
"sources":["/usr/local/lib/haxe/std/js/_std/EReg.hx","/usr/local/lib/haxe/std/js/_std/HxOverrides.hx","/Users/matthijs/Documents/workingdir/haxe/haxejs/10thxpromise/code/src/Main.hx","/usr/local/lib/haxe/std/js/_std/Std.hx","/usr/local/lib/haxe/std/StringBuf.hx","/usr/local/lib/haxe/std/StringTools.hx","/usr/local/lib/haxe/std/haxe/CallStack.hx","/usr/local/lib/haxe/std/js/Boot.hx","/usr/local/lib/haxe/lib/thx,core/0,42,1/src/thx/Error.hx","/usr/local/lib/haxe/lib/thx,core/0,42,1/src/thx/Timer.hx","/usr/local/lib/haxe/lib/thx,core/0,42,1/src/thx/error/ErrorWrapper.hx","/usr/local/lib/haxe/lib/thx,promise/0,6,0/src/thx/promise/Future.hx","/usr/local/lib/haxe/lib/thx,promise/0,6,0/src/thx/promise/Promise.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class EReg {\n\n\tvar r : HaxeRegExp;\n\n\tpublic inline function new( r : String, opt : String ) : Void {\n\t\tthis.r = new HaxeRegExp(r, opt.split(\"u\").join(\"\")); // 'u' (utf8) depends on page encoding\n\t}\n\n\tpublic function match( s : String ) : Bool {\n\t\tif( r.global ) r.lastIndex = 0;\n\t\tr.m = r.exec(s);\n\t\tr.s = s;\n\t\treturn (r.m != null);\n\t}\n\n\tpublic function matched( n : Int ) : String {\n\t\treturn if( r.m != null && n >= 0 && n < r.m.length ) r.m[n] else throw \"EReg::matched\";\n\t}\n\n\tpublic function matchedLeft() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn r.s.substr(0,r.m.index);\n\t}\n\n\tpublic function matchedRight() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\tvar sz = r.m.index+r.m[0].length;\n\t\treturn r.s.substr(sz,r.s.length-sz);\n\t}\n\n\tpublic function matchedPos() : { pos : Int, len : Int } {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn { pos : r.m.index, len : r.m[0].length };\n\t}\n\n\tpublic function matchSub( s : String, pos : Int, len : Int = -1):Bool {\n\t\treturn if (r.global) {\n\t\t\tr.lastIndex = pos;\n\t\t\tr.m = r.exec(len < 0 ? s : s.substr(0, pos + len));\n\t\t\tvar b = r.m != null;\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t}\n\t\t\tb;\n\t\t} else {\n\t\t\t// TODO: check some ^/$ related corner cases\n\t\t\tvar b = match( len < 0 ? s.substr(pos) : s.substr(pos,len) );\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t\tr.m.index += pos;\n\t\t\t}\n\t\t\tb;\n\t\t}\n\t}\n\n\tpublic function split( s : String ) : Array<String> {\n\t\t// we can't use directly s.split because it's ignoring the 'g' flag\n\t\tvar d = \"#__delim__#\";\n\t\treturn untyped s.replace(r,d).split(d);\n\t}\n\n\tpublic inline function replace( s : String, by : String ) : String {\n\t\treturn untyped s.replace(r,by);\n\t}\n\n\tpublic function map( s : String, f : EReg -> String ) : String {\n\t\tvar offset = 0;\n\t\tvar buf = new StringBuf();\n\t\tdo {\n\t\t\tif (offset >= s.length)\n\t\t\t\tbreak;\n\t\t\telse if (!matchSub(s, offset)) {\n\t\t\t\tbuf.add(s.substr(offset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar p = matchedPos();\n\t\t\tbuf.add(s.substr(offset, p.pos - offset));\n\t\t\tbuf.add(f(this));\n\t\t\tif (p.len == 0) {\n\t\t\t\tbuf.add(s.substr(p.pos, 1));\n\t\t\t\toffset = p.pos + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p.pos + p.len;\n\t\t} while (r.global);\n\t\tif (!r.global && offset > 0 && offset < s.length)\n\t\t\tbuf.add(s.substr(offset));\n\t\treturn buf.toString();\n\t}\n}\n\n@:native(\"RegExp\")\nprivate extern class HaxeRegExp extends js.RegExp {\n\tvar m:js.RegExp.RegExpMatch;\n\tvar s:String;\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\n\tstatic function dateStr( date :Date ) : String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear()\n\t\t\t+\"-\"+(if( m < 10 ) \"0\"+m else \"\"+m)\n\t\t\t+\"-\"+(if( d < 10 ) \"0\"+d else \"\"+d)\n\t\t\t+\" \"+(if( h < 10 ) \"0\"+h else \"\"+h)\n\t\t\t+\":\"+(if( mi < 10 ) \"0\"+mi else \"\"+mi)\n\t\t\t+\":\"+(if( s < 10 ) \"0\"+s else \"\"+s);\n\t}\n\n\tstatic function strDate( s : String ) : Date {\n\t\tswitch( s.length ) {\n\t\tcase 8: // hh:mm:ss\n\t\t\tvar k = s.split(\":\");\n\t\t\tvar d : Date = untyped __new__(Date);\n\t\t\tuntyped d[\"setTime\"](0);\n\t\t\tuntyped d[\"setUTCHours\"](k[0]);\n\t\t\tuntyped d[\"setUTCMinutes\"](k[1]);\n\t\t\tuntyped d[\"setUTCSeconds\"](k[2]);\n\t\t\treturn d;\n\t\tcase 10: // YYYY-MM-DD\n\t\t\tvar k = s.split(\"-\");\n\t\t\treturn new Date(cast k[0],cast untyped k[1] - 1,cast k[2],0,0,0);\n\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\tvar k = s.split(\" \");\n\t\t\tvar y = k[0].split(\"-\");\n\t\t\tvar t = k[1].split(\":\");\n\t\t\treturn new Date(cast y[0],cast untyped y[1] - 1,cast y[2],cast t[0],cast t[1],cast t[2]);\n\t\tdefault:\n\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\tstatic function cca( s : String, index : Int ) : Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif( x != x ) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\tstatic function substr( s : String, pos : Int, ?len : Int ) : String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (untyped s).substr(pos, len);\n\t}\n\n\tstatic function indexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0) i = 0;\n\t\t}\n\t\twhile (i < len)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function lastIndexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>( a : Array<T>, obj : T ) {\n\t\tvar i = a.indexOf(obj);\n\t\tif( i == -1 ) return false;\n\t\ta.splice(i,1);\n\t\treturn true;\n\t}\n\n\tstatic function iter<T>( a : Array<T> ) : Iterator<T> untyped {\n\t\treturn {\n\t\t\tcur : 0,\n\t\t\tarr : a,\n\t\t\thasNext : function() {\n\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic function __init__() untyped {\n#if (js_es < 5)\n\t\t__feature__('HxOverrides.indexOf', if( Array.prototype.indexOf ) __js__(\"HxOverrides\").indexOf = function(a,o,i) return Array.prototype.indexOf.call(a, o, i));\n\t\t__feature__('HxOverrides.lastIndexOf', if( Array.prototype.lastIndexOf ) __js__(\"HxOverrides\").lastIndexOf = function(a,o,i) return Array.prototype.lastIndexOf.call(a, o, i));\n#end\n\t}\n\n}\n","package ;\n\nimport thx.Error;\nimport thx.Timer;\n\nusing thx.promise.Promise;\n\nclass Main {\n\n\tpublic function new()\n\t{\n\t\ttrace (\"thx.promise example\");\n\n\t\tvar promise = Promise.create(function(resolve : String -> Void, reject : Error -> Void) {\n\t\t\tTimer.delay(function() {\n\t\t\t\tif(Math.random() < 0.5)\n\t\t\t\t\tresolve(\"success\");\n\t\t\t\telse\n\t\t\t\t\treject(new Error(\"failure\"));\n\t\t\t}, 100);\n\t\t});\n\n\t\tpromise.either(\n\t\t\tfunction(value) trace('SUCCESS $value'),\n\t\t\tfunction(error) trace('ERROR $error')\n\t\t);\n\t}\n\n\tstatic public function main() : Void\n\t{\n\t\tvar main = new Main();\n\t}\n}","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\t@:pure\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\t@:pure\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static inline function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if (js_es < 5)\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA String buffer is an efficient way to build a big string by appending small\n\telements together.\n\n\tIts cross-platform implementation uses String concatenation internally, but\n\tStringBuf may be optimized for different targets.\n\n\tUnlike String, an instance of StringBuf is not immutable in the sense that\n\tit can be passed as argument to functions which modify it by appending more\n\tvalues. However, the internal buffer cannot be modified.\n**/\nclass StringBuf {\n\n\tvar b:String;\n\n\t/**\n\t\tThe length of `this` StringBuf in characters.\n\t**/\n\tpublic var length(get,never) : Int;\n\n\t/**\n\t\tCreates a new StringBuf instance.\n\n\t\tThis may involve initialization of the internal buffer.\n\t**/\n\tpublic inline function new() {\n\t\tb = \"\";\n\t}\n\n\tinline function get_length() : Int {\n\t\treturn b.length;\n\t}\n\n\t/**\n\t\tAppends the representation of `x` to `this` StringBuf.\n\n\t\tThe exact representation of `x` may vary per platform. To get more\n\t\tconsistent behavior, this function should be called with\n\t\tStd.string(x).\n\n\t\tIf `x` is null, the String \"null\" is appended.\n\t**/\n\tpublic inline function add<T>( x : T ) : Void {\n\t\tb += x;\n\t}\n\n\t/**\n\t\tAppends the character identified by `c` to `this` StringBuf.\n\n\t\tIf `c` is negative or has another invalid value, the result is\n\t\tunspecified.\n\t**/\n\tpublic inline function addChar( c : Int ) : Void {\n\t\tb += String.fromCharCode(c);\n\t}\n\n\t/**\n\t\tAppends a substring of `s` to `this` StringBuf.\n\n\t\tThis function expects `pos` and `len` to describe a valid substring of\n\t\t`s`, or else the result is unspecified. To get more robust behavior,\n\t\t`this.add(s.substr(pos,len))` can be used instead.\n\n\t\tIf `s` or `pos` are null, the result is unspecified.\n\n\t\tIf `len` is omitted or null, the substring ranges from `pos` to the end\n\t\tof `s`.\n\t**/\n\tpublic inline function addSub( s : String, pos : Int, ?len : Int) : Void {\n\t\tb += (len == null ? s.substr(pos) : s.substr(pos, len));\n\t}\n\n\t/**\n\t\tReturns the content of `this` StringBuf as String.\n\n\t\tThe buffer is not emptied by this operation.\n\t**/\n\tpublic inline function toString() : String {\n\t\treturn b;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)\n\tto the `String` class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\n#if cpp\nusing cpp.NativeString;\n#end\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp && !lua) inline #end public static function urlEncode( s : String ) : String {\n\t\t#if flash\n\t\t\treturn untyped __global__[\"encodeURIComponent\"](s);\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped encodeURIComponent(s);\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLEncode();\n\t\t#elseif java\n\t\t\treturn postProcessUrlEncode(java.net.URLEncoder.encode(s, \"UTF-8\"));\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.EscapeDataString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.quote(s, \"\");\n\t\t#elseif hl\n\t\t\tvar len = 0;\n\t\t\tvar b = @:privateAccess s.bytes.urlEncode(len);\n\t\t\treturn @:privateAccess String.__alloc__(b,len);\n\t\t#elseif lua\n\t\t\ts = lua.NativeStringTools.gsub(s, \"\\n\", \"\\r\\n\");\n\t\t\ts = lua.NativeStringTools.gsub(s, \"([^%w %-%_%.%~])\", function (c) {\n\t\t\t\treturn lua.NativeStringTools.format(\"%%%02X\", lua.NativeStringTools.byte(c) + '');\n\t\t\t});\n\t\t\ts = lua.NativeStringTools.gsub(s, \" \", \"+\");\n\t\t\treturn s;\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n#if java\n\tprivate static function postProcessUrlEncode( s : String ) : String {\n\t\tvar ret = new StringBuf();\n\t\tvar i = 0,\n\t\t    len = s.length;\n\t\twhile (i < len) {\n\t\t\tswitch(_charAt(s, i++)) {\n\t\t\tcase '+'.code:\n\t\t\t\tret.add('%20');\n\t\t\tcase '%'.code if (i <= len - 2):\n\t\t\t\tvar c1 = _charAt(s, i++),\n\t\t\t\t    c2 = _charAt(s, i++);\n\t\t\t\tswitch[c1, c2] {\n\t\t\t\tcase ['2'.code, '1'.code]:\n\t\t\t\t\tret.addChar('!'.code);\n\t\t\t\tcase ['2'.code, '7'.code]:\n\t\t\t\t\tret.addChar('\\''.code);\n\t\t\t\tcase ['2'.code, '8'.code]:\n\t\t\t\t\tret.addChar('('.code);\n\t\t\t\tcase ['2'.code, '9'.code]:\n\t\t\t\t\tret.addChar(')'.code);\n\t\t\t\tcase ['7'.code, 'E'.code] | ['7'.code, 'e'.code]:\n\t\t\t\t\tret.addChar('~'.code);\n\t\t\t\tcase _:\n\t\t\t\t\tret.addChar('%'.code);\n\t\t\t\t\tret.addChar(cast c1);\n\t\t\t\t\tret.addChar(cast c2);\n\t\t\t\t}\n\t\t\tcase chr:\n\t\t\t\tret.addChar(cast chr);\n\t\t\t}\n\t\t}\n\t\treturn ret.toString();\n\t}\n#end\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp && !lua) inline #end public static function urlDecode( s : String ) : String {\n\t\t#if flash\n\t\t\treturn untyped __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLDecode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLDecoder.decode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.UnescapeDataString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.unquote(s);\n\t\t#elseif hl\n\t\t\tvar len = 0;\n\t\t\tvar b = @:privateAccess s.bytes.urlDecode(len);\n\t\t\treturn @:privateAccess String.__alloc__(b,len);\n\t\t#elseif lua\n\t\t\ts = lua.NativeStringTools.gsub (s, \"+\", \" \");\n\t\t\ts = lua.NativeStringTools.gsub (s, \"%%(%x%x)\",\n\t\t\t\tfunction(h) {return lua.NativeStringTools.char(lua.Lua.tonumber(h,16));});\n\t\t\ts = lua.NativeStringTools.gsub (s, \"\\r\\n\", \"\\n\");\n\t\t\treturn s;\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape( s : String, ?quotes : Bool ) : String {\n\t\ts = s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t\treturn quotes ? s.split('\"').join(\"&quot;\").split(\"'\").join(\"&#039;\") : s;\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: `htmlUnescape(htmlEscape(s)) == s`\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape( s : String ) : String {\n\t\treturn s.split(\"&gt;\").join(\">\").split(\"&lt;\").join(\"<\").split(\"&quot;\").join('\"').split(\"&#039;\").join(\"'\").split(\"&amp;\").join(\"&\");\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is `null`, the result is unspecified.\n\n\t\tIf `start` is the empty String `\"\"`, the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function startsWith( s : String, start : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#elseif cpp\n\t\tif (s.length<start.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str();\n\t\tvar p1 = start.c_str();\n\t\tfor(i in 0...start.length)\n\t\t\tif ( p0.at(i) != p1.at(i) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#elseif hl\n\t\treturn @:privateAccess (s.length >= start.length && s.bytes.compare(0,start.bytes,0,start.length<<1) == 0);\n\t\t#else\n\t\treturn( s.length >= start.length && s.substr(0, start.length) == start );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is `null`, the result is unspecified.\n\n\t\tIf `end` is the empty String `\"\"`, the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function endsWith( s : String, end : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#elseif cpp\n\t\tif (s.length<end.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str().add( s.length-end.length );\n\t\tvar p1 = end.c_str();\n\t\tfor(i in 0...end.length)\n\t\t\tif ( p0.at(i) != p1.at(i) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#elseif hl\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn @:privateAccess (slen >= elen && s.bytes.compare((slen - elen) << 1, end.bytes, 0, elen << 1) == 0);\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn( slen >= elen && s.substr(slen - elen, elen) == end );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String `\"\"`, or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace( s : String, pos : Int ) : Bool {\n\t\t#if (python || lua)\n\t\tif (s.length == 0 || pos < 0 || pos >= s.length) return false;\n\t\t#end\n\t\tvar c = s.charCodeAt( pos );\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls `isSpace()` to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\t\tresult is the empty String `\"\"`.\n\t**/\n\tpublic #if cs inline #end static function ltrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,r) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 )\n\t\t\treturn s.substr(r, l-r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls `isSpace()` to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\t\tresult is the empty String `\"\"`.\n\t**/\n\tpublic #if cs inline #end static function rtrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,l-r-1) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 ){\n\t\t\treturn s.substr(0, l-r);\n\t\t}else{\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for `ltrim(rtrim(s))`.\n\t**/\n\tpublic #if (cs || java) inline #end static function trim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn untyped s.trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = c + s;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = s + c;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReplace all occurrences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String `\"\"`, `by` is inserted after each character\n\t\tof `s`. If `by` is also the empty String `\"\"`, `s` remains unchanged.\n\n\t\tThis is a convenience function for `s.split(sub).join(by)`.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace( s : String, sub : String, by : String ) : String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits `length` equals `digits`.\n\t**/\n\tpublic static function hex( n : Int, ?digits : Int ) {\n\t\t#if flash\n\t\t\tvar n : UInt = n;\n\t\t\tvar s : String = untyped n.toString(16);\n\t\t\ts = s.toUpperCase();\n\t\t#else\n\t\t\tvar s = \"\";\n\t\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\t\tdo {\n\t\t\t\ts = hexChars.charAt(n&15) + s;\n\t\t\t\tn >>>= 4;\n\t\t\t} while( n > 0 );\n\t\t#end\n\t\t#if python\n\t\tif (digits != null && s.length < digits) {\n\t\t\tvar diff = digits - s.length;\n\t\t\tfor (_ in 0...diff) {\n\t\t\t\ts = \"0\" + s;\n\t\t\t}\n\t\t}\n\t\t#else\n\t\tif( digits != null )\n\t\t\twhile( s.length < digits )\n\t\t\t\ts = \"0\"+s;\n\t\t#end\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than `String.charCodeAt()` on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tEnd of file status can be checked by calling `StringTools.isEof()` with\n\t\tthe returned value as argument.\n\n\t\tThis operation is not guaranteed to work if `s` contains the `\\0`\n\t\tcharacter.\n\t**/\n\tpublic static inline function fastCodeAt( s : String, index : Int ) : Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s.cca(index);\n\t\t#elseif java\n\t\treturn ( index < s.length ) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn ( cast(index, UInt) < s.length ) ? cast(s[index], Int) : -1;\n\t\t#elseif js\n\t\treturn (untyped s).charCodeAt(index);\n\t\t#elseif python\n\t\treturn if (index >= s.length) -1 else python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t\t#elseif hl\n\t\treturn @:privateAccess s.bytes.getUI16(index << 1);\n\t\t#elseif lua\n\t\treturn lua.NativeStringTools.byte(s,index+1);\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/*\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t*/\n\t@:noUsing public static inline function isEof( c : Int ) : Bool {\n\t\t#if (flash || cpp || hl)\n\t\treturn c == 0;\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif (neko || lua)\n\t\treturn c == null;\n\t\t#elseif cs\n\t\treturn c == -1;\n\t\t#elseif java\n\t\treturn c == -1;\n\t\t#elseif python\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a String that can be used as a single command line argument\n\t\ton Unix.\n\t\tThe input will be quoted, or escaped if necessary.\n\t*/\n\tpublic static function quoteUnixArg(argument:String):String {\n\t\t// Based on cpython's shlex.quote().\n\t\t// https://hg.python.org/cpython/file/a3f076d4f54f/Lib/shlex.py#l278\n\n\t\tif (argument == \"\")\n\t\t\treturn \"''\";\n\n\t\tif (!~/[^a-zA-Z0-9_@%+=:,.\\/-]/.match(argument))\n\t\t\treturn argument;\n\n\t\t// use single quotes, and put single quotes into double quotes\n\t\t// the string $'b is then quoted as '$'\"'\"'b'\n\t\treturn \"'\" + replace(argument, \"'\", \"'\\\"'\\\"'\") + \"'\";\n\t}\n\n\t/**\n\t\tCharacter codes of the characters that will be escaped by `quoteWinArg(_, true)`.\n\t*/\n\tpublic static var winMetaCharacters = [\" \".code, \"(\".code, \")\".code, \"%\".code, \"!\".code, \"^\".code, \"\\\"\".code, \"<\".code, \">\".code, \"&\".code, \"|\".code, \"\\n\".code, \"\\r\".code, \",\".code, \";\".code];\n\n\t/**\n\t\tReturns a String that can be used as a single command line argument\n\t\ton Windows.\n\t\tThe input will be quoted, or escaped if necessary, such that the output\n\t\twill be parsed as a single argument using the rule specified in\n\t\thttp://msdn.microsoft.com/en-us/library/ms880421\n\n\t\tExamples:\n\t\t```\n\t\tquoteWinArg(\"abc\") == \"abc\";\n\t\tquoteWinArg(\"ab c\") == '\"ab c\"';\n\t\t```\n\t*/\n\tpublic static function quoteWinArg(argument:String, escapeMetaCharacters:Bool):String {\n\t\t// If there is no space, tab, back-slash, or double-quotes, and it is not an empty string.\n\t\tif (!~/^[^ \\t\\\\\"]+$/.match(argument)) {\n\n\t\t\t// Based on cpython's subprocess.list2cmdline().\n\t\t\t// https://hg.python.org/cpython/file/50741316dd3a/Lib/subprocess.py#l620\n\n\t\t\tvar result = new StringBuf();\n\t\t\tvar needquote = argument.indexOf(\" \") != -1 || argument.indexOf(\"\\t\") != -1 || argument == \"\";\n\n\t\t\tif (needquote)\n\t\t\t\tresult.add('\"');\n\n\t\t\tvar bs_buf = new StringBuf();\n\t\t\tfor (i in 0...argument.length) {\n\t\t\t\tswitch (argument.charCodeAt(i)) {\n\t\t\t\t\tcase \"\\\\\".code:\n\t\t\t\t\t\t// Don't know if we need to double yet.\n\t\t\t\t\t\tbs_buf.add(\"\\\\\");\n\t\t\t\t\tcase '\"'.code:\n\t\t\t\t\t\t// Double backslashes.\n\t\t\t\t\t\tvar bs = bs_buf.toString();\n\t\t\t\t\t\tresult.add(bs);\n\t\t\t\t\t\tresult.add(bs);\n\t\t\t\t\t\tbs_buf = new StringBuf();\n\t\t\t\t\t\tresult.add('\\\\\"');\n\t\t\t\t\tcase c:\n\t\t\t\t\t\t// Normal char\n\t\t\t\t\t\tif (bs_buf.length > 0) {\n\t\t\t\t\t\t\tresult.add(bs_buf.toString());\n\t\t\t\t\t\t\tbs_buf = new StringBuf();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.addChar(c);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add remaining backslashes, if any.\n\t\t\tresult.add(bs_buf.toString());\n\n\t\t\tif (needquote) {\n\t\t\t\tresult.add(bs_buf.toString());\n\t\t\t\tresult.add('\"');\n\t\t\t}\n\n\t\t\targument = result.toString();\n\t\t}\n\n\t\tif (escapeMetaCharacters) {\n\t\t\tvar result = new StringBuf();\n\t\t\tfor (i in 0...argument.length) {\n\t\t\t\tvar c = argument.charCodeAt(i);\n\t\t\t\tif (winMetaCharacters.indexOf(c) >= 0) {\n\t\t\t\t\tresult.addChar(\"^\".code);\n\t\t\t\t}\n\t\t\t\tresult.addChar(c);\n\t\t\t}\n\t\t\treturn result.toString();\n\t\t} else {\n\t\t\treturn argument;\n\t\t}\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16 return untyped str._charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\",\"url_encode\",1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\",\"url_decode\",1);\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tElements return by `CallStack` methods.\n**/\nenum StackItem {\n\tCFunction;\n\tModule( m : String );\n\tFilePos( s : Null<StackItem>, file : String, line : Int );\n\tMethod( classname : String, method : String );\n\tLocalFunction( ?v : Int );\n}\n\n/**\n\tGet information about the call stack.\n**/\nclass CallStack {\n\t#if js\n\tstatic var lastException:js.Error;\n\n\tstatic function getStack(e:js.Error):Array<StackItem> {\n\t\tif (e == null) return [];\n\t\t// https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\t\tvar oldValue = (untyped Error).prepareStackTrace;\n\t\t(untyped Error).prepareStackTrace = function (error, callsites :Array<Dynamic>) {\n\t\t\tvar stack = [];\n\t\t\tfor (site in callsites) {\n\t\t\t\tif (wrapCallSite != null) site = wrapCallSite(site);\n\t\t\t\tvar method = null;\n\t\t\t\tvar fullName :String = site.getFunctionName();\n\t\t\t\tif (fullName != null) {\n\t\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\tvar className = fullName.substr(0, idx);\n\t\t\t\t\t\tvar methodName = fullName.substr(idx+1);\n\t\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstack.push(FilePos(method, site.getFileName(), site.getLineNumber()));\n\t\t\t}\n\t\t\treturn stack;\n\t\t}\n\t\tvar a = makeStack(e.stack);\n\t\t(untyped Error).prepareStackTrace = oldValue;\n\t\treturn a;\n\t}\n\n\t// support for source-map-support module\n\t@:noCompletion\n\tpublic static var wrapCallSite:Dynamic->Dynamic;\n\t#end\n\n\t/**\n\t\tReturn the call stack elements, or an empty array if not available.\n\t**/\n\tpublic static function callStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\tvar a = makeStack(untyped __dollar__callstack());\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\tvar a = makeStack( new flash.errors.Error().getStackTrace() );\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif php\n\t\t\treturn makeStack(\"%s\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_call_stack(true);\n\t\t\treturn makeStack(s);\n\t\t#elseif js\n\t\t\ttry {\n\t\t\t\tthrow new js.Error();\n\t\t\t} catch( e : Dynamic ) {\n\t\t\t\tvar a = getStack(e);\n\t\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.lang.Thread.currentThread().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(1, true));\n\t\t#elseif python\n\t\t\tvar stack = [];\n\t\t\tvar infos = python.lib.Traceback.extract_stack();\n\t\t\tinfos.pop();\n\t\t\tinfos.reverse();\n\t\t\tfor (elem in infos)\n\t\t\t\tstack.push(FilePos(null, elem._1, elem._2));\n\t\t\treturn stack;\n\t\t#elseif lua\n\t\t\tvar stack = [];\n\t\t\tvar infos = lua.Debug.traceback();\n\t\t\tvar luastack = infos.split(\"\\n\").slice(2,-1);\n\t\t\tfor (s in luastack){\n\t\t\t\tvar parts = s.split(\":\");\n\t\t\t\tvar file  = parts[0];\n\t\t\t\tvar line  = parts[1];\n\t\t\t\t// TODO: Give more information for FilePos\n\t\t\t\tstack.push(FilePos(null, file, Std.parseInt(line)));\n\t\t\t}\n\t\t\treturn stack;\n\t\t#elseif hl\n\t\t\ttry {\n\t\t\t\tthrow null;\n\t\t\t} catch( e : Dynamic ) {\n\t\t\t\tvar st = _getExceptionStack();\n\t\t\t\treturn makeStack(st.length > 2 ? st.sub(2,st.length - 2) : st);\n\t\t\t}\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t#if hl\n\t@:hlNative(\"std\", \"exception_stack\") static function _getExceptionStack() : hl.NativeArray<hl.Bytes> { return null; }\n\t#end\n\n\t/**\n\t\tReturn the exception stack : this is the stack elements between\n\t\tthe place the last exception was thrown and the place it was\n\t\tcaught, or an empty array if not available.\n\t**/\n\t#if cpp @:noDebug #end /* Do not mess up the exception stack */\n\tpublic static function exceptionStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\treturn makeStack(untyped __dollar__excstack());\n\t\t#elseif as3\n\t\t\treturn new Array();\n\t\t#elseif hl\n\t\t\treturn makeStack(_getExceptionStack());\n\t\t#elseif flash\n\t\t\tvar err : flash.errors.Error = untyped flash.Boot.lastError;\n\t\t\tif( err == null ) return new Array();\n\t\t\tvar a = makeStack( err.getStackTrace() );\n\t\t\tvar c = callStack();\n\t\t\tvar i = c.length - 1;\n\t\t\twhile( i > 0 ) {\n\t\t\t\tif( Std.string(a[a.length-1]) == Std.string(c[i]) )\n\t\t\t\t\ta.pop();\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif php\n\t\t\treturn makeStack(\"%e\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_exception_stack();\n\t\t\treturn makeStack(s);\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.internal.Exceptions.currentException().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// stack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(cs.internal.Exceptions.exception, true));\n\t\t#elseif python\n\t\t\tvar stack = [];\n\t\t\tvar exc = python.lib.Sys.exc_info();\n\t\t\tif (exc._3 != null)\n\t\t\t{\n\t\t\t\tvar infos = python.lib.Traceback.extract_tb(exc._3);\n\t\t\t\tinfos.reverse();\n\t\t\t\tfor (elem in infos)\n\t\t\t\t\tstack.push(FilePos(null, elem._1, elem._2));\n\t\t\t}\n\t\t\treturn stack;\n\t\t#elseif js\n\t\t\treturn untyped __define_feature__(\"haxe.CallStack.exceptionStack\", getStack(lastException));\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a representation of the stack as a printable string.\n\t**/\n\tpublic static function toString( stack : Array<StackItem> ) {\n\t\tvar b = new StringBuf();\n\t\tfor( s in stack ) {\n\t\t\tb.add(\"\\nCalled from \");\n\t\t\titemToString(b,s);\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tprivate static function itemToString( b : StringBuf, s ) {\n\t\tswitch( s ) {\n\t\tcase CFunction:\n\t\t\tb.add(\"a C function\");\n\t\tcase Module(m):\n\t\t\tb.add(\"module \");\n\t\t\tb.add(m);\n\t\tcase FilePos(s,file,line):\n\t\t\tif( s != null ) {\n\t\t\t\titemToString(b,s);\n\t\t\t\tb.add(\" (\");\n\t\t\t}\n\t\t\tb.add(file);\n\t\t\tb.add(\" line \");\n\t\t\tb.add(line);\n\t\t\tif( s != null ) b.add(\")\");\n\t\tcase Method(cname,meth):\n\t\t\tb.add(cname);\n\t\t\tb.add(\".\");\n\t\t\tb.add(meth);\n\t\tcase LocalFunction(n):\n\t\t\tb.add(\"local function #\");\n\t\t\tb.add(n);\n\t\t}\n\t}\n\n\t#if cpp @:noDebug #end /* Do not mess up the exception stack */\n\tprivate static function makeStack(s #if cs : cs.system.diagnostics.StackTrace #elseif hl : hl.NativeArray<hl.Bytes> #end) {\n\t\t#if neko\n\t\t\tvar a = new Array();\n\t\t\tvar l = untyped __dollar__asize(s);\n\t\t\tvar i = 0;\n\t\t\twhile( i < l ) {\n\t\t\t\tvar x = s[i++];\n\t\t\t\tif( x == null )\n\t\t\t\t\ta.unshift(CFunction);\n\t\t\t\telse if( untyped __dollar__typeof(x) == __dollar__tstring )\n\t\t\t\t\ta.unshift(Module(new String(x)));\n\t\t\t\telse\n\t\t\t\t\ta.unshift(FilePos(null,new String(untyped x[0]),untyped x[1]));\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\tvar a = new Array();\n\t\t\tvar r = ~/at ([^\\/]+?)\\$?(\\/[^\\(]+)?\\(\\)(\\[(.*?):([0-9]+)\\])?/;\n\t\t\tvar rlambda = ~/^MethodInfo-([0-9]+)$/g;\n\t\t\twhile( r.match(s) ) {\n\t\t\t\tvar cl = r.matched(1).split(\"::\").join(\".\");\n\t\t\t\tvar meth = r.matched(2);\n\t\t\t\tvar item;\n\t\t\t\tif( meth == null ) {\n\t\t\t\t\tif( rlambda.match(cl) )\n\t\t\t\t\t\titem = LocalFunction(Std.parseInt(rlambda.matched(1)));\n\t\t\t\t\telse\n\t\t\t\t\t\titem = Method(cl,\"new\");\n\t\t\t\t} else\n\t\t\t\t\titem = Method(cl,meth.substr(1));\n\t\t\t\tif( r.matched(3) != null )\n\t\t\t\t\titem = FilePos( item, r.matched(4), Std.parseInt(r.matched(5)) );\n\t\t\t\ta.push(item);\n\t\t\t\ts = r.matchedRight();\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif php\n\t\t\tif (!untyped __call__(\"isset\", __var__(\"GLOBALS\", s)))\n\t\t\t\treturn [];\n\t\t\tvar a : Array<String> = untyped __var__(\"GLOBALS\", s);\n\t\t\tvar m = [];\n\t\t\tfor( i in 0...a.length - ((s == \"%s\") ? 2 : 0)) {\n\t\t\t\tvar d = a[i].split(\"::\");\n\t\t\t\tm.unshift(Method(d[0],d[1]));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif cpp\n\t\t\tvar stack : Array<String> = s;\n\t\t\tvar m = new Array<StackItem>();\n\t\t\tfor(func in stack) {\n\t\t\t\tvar words = func.split(\"::\");\n\t\t\t\tif (words.length==0)\n\t\t\t\t\tm.push(CFunction)\n\t\t\t\telse if (words.length==2)\n\t\t\t\t\tm.push(Method(words[0],words[1]));\n\t\t\t\telse if (words.length==4)\n\t\t\t\t\tm.push(FilePos( Method(words[0],words[1]),words[2],Std.parseInt(words[3])));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif js\n\t\t\tif (s == null) {\n\t\t\t\treturn [];\n\t\t\t} else if ((untyped __js__(\"typeof\"))(s) == \"string\") {\n\t\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\t\tvar stack : Array<String> = s.split(\"\\n\");\n\t\t\t\tif( stack[0] == \"Error\" ) stack.shift();\n\t\t\t\tvar m = [];\n\t\t\t\tvar rie10 = ~/^   at ([A-Za-z0-9_. ]+) \\(([^)]+):([0-9]+):([0-9]+)\\)$/;\n\t\t\t\tfor( line in stack ) {\n\t\t\t\t\tif( rie10.match(line) ) {\n\t\t\t\t\t\tvar path = rie10.matched(1).split(\".\");\n\t\t\t\t\t\tvar meth = path.pop();\n\t\t\t\t\t\tvar file = rie10.matched(2);\n\t\t\t\t\t\tvar line = Std.parseInt(rie10.matched(3));\n\t\t\t\t\t\tm.push(FilePos( meth == \"Anonymous function\" ? LocalFunction() : meth == \"Global code\" ? null : Method(path.join(\".\"),meth), file, line ));\n\t\t\t\t\t} else\n\t\t\t\t\t\tm.push(Module(StringTools.trim(line))); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t\treturn m;\n\t\t\t} else {\n\t\t\t\treturn cast s;\n\t\t\t}\n\t\t#elseif cs\n\t\t\tvar stack = [];\n\t\t\tfor (i in 0...s.FrameCount)\n\t\t\t{\n\t\t\t\tvar frame = s.GetFrame(i);\n\t\t\t\tvar m = frame.GetMethod();\n\n\t\t\t\tif (m == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvar method = StackItem.Method(m.ReflectedType.ToString(), m.Name);\n\n\t\t\t\tvar fileName = frame.GetFileName();\n\t\t\t\tvar lineNumber = frame.GetFileLineNumber();\n\n\t\t\t\tif (fileName != null || lineNumber >= 0)\n\t\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\t\telse\n\t\t\t\t\tstack.push(method);\n\t\t\t}\n\t\t\treturn stack;\n\t\t#elseif hl\n\t\t\tvar stack = [];\n\t\t\tvar r = ~/^([A-Za-z0-9.$_]+)\\.([A-Za-z0-9_]+)\\((.+):([0-9]+)\\)$/;\n\t\t\tfor( i in 0...s.length-1 ) {\n\t\t\t\tvar str = @:privateAccess String.fromUCS2(s[i]);\n\t\t\t\tif( r.match(str) )\n\t\t\t\t\tstack.push(FilePos(Method(r.matched(1), r.matched(2)), r.matched(3), Std.parseInt(r.matched(4))));\n\t\t\t\telse\n\t\t\t\t\tstack.push(Module(str));\n\t\t\t}\n\t\t\treturn stack;\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nprivate class HaxeError extends js.Error {\n\n\tvar val:Dynamic;\n\n\tpublic function new(val:Dynamic) untyped {\n\t\tsuper();\n\t\tthis.val = __define_feature__(\"js.Boot.HaxeError\", val);\n\t\tthis.message = String(val);\n\t\tif (js.Error.captureStackTrace) js.Error.captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):Dynamic untyped {\n\t\treturn if (__instanceof__(val, js.Error)) val else new HaxeError(val);\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") && __typeof__(tostr) == \"function\" ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\" && untyped __js__(\"(o|0) === o\");\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if ( (untyped __js__(\"typeof\"))(cl) == \"object\" && __isNativeObj(cl) ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n\tstatic var __toStr = untyped ({}).toString;\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name = untyped __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn untyped js.Lib.global[name];\n\t}\n\n}\n","package thx;\n\nimport haxe.PosInfos;\nimport haxe.CallStack;\nimport thx.error.ErrorWrapper;\n\n/**\nDefines a generic Error type. When the target platform is JS, `Error` extends the native\n`js.Error` type.\n**/\nclass Error #if js extends js.Error #end {\n/**\nIt creates an instance of Error from any value.\n\nIf `err` is already an instance of `Error`, it is returned and nothing is created.\n**/\n  public static function fromDynamic(err: Dynamic, ?pos: PosInfos): Error {\n    if(Std.is(err, Error))\n      return cast err;\n    return new ErrorWrapper(\"\"+err, err, null, pos);\n  }\n\n#if !js\n/**\nThe text message associated with the error.\n**/\n  public var message(default, null): String;\n#end\n/**\nThe location in code where the error has been instantiated.\n**/\n  public var pos(default, null): PosInfos;\n\n/**\nThe collected error stack.\n**/\n  public var stackItems(default, null): Array<StackItem>;\n\n/**\nThe `Error` constructor only requires a steing message. `stack` and `pos` are automatically\npopulate but can be provided if preferred.\n**/\n  public function new(message: String, ?stack: Array<StackItem>, ?pos: PosInfos) {\n#if js\n    super(message);\n#end\n    this.message = message;\n\n    if(null == stack) {\n      stack = try CallStack.exceptionStack() catch(e: Dynamic) [];\n      if(stack.length == 0)\n        stack = try CallStack.callStack() catch(e: Dynamic) [];\n    }\n    this.stackItems = stack;\n    this.pos = pos;\n  }\n\n  public function toString()\n    return message + \"\\nfrom: \" + getPosition() + \"\\n\\n\" + stackToString();\n\n  public function getPosition()\n    return pos.className + \".\" + pos.methodName + \"() at \" + pos.lineNumber;\n\n  public function stackToString()\n    return CallStack.toString(stackItems);\n}\n","package thx;\n\n/**\n`Timer` provides several meaning to delay the execution of code. At the moment it is only\nimplemented for platforms that have a native concept of Timer like Swf and JavaScript or c++/Neko\nwith OpenFL or NME.\n\nAll of the Timer methods return a function with signature Void -> Void that can be used to cancel\nthe timer.\n\n```haxe\n// set the execution delayed by 200ms\nvar cancel = Timer.delay(doSomethingLater, 200);\n\n// cancel immediately (doSomethingLater will never be executed)\ncancel();\n```\n\nNote that calling the cancel function multiple times have no effect after the first execution.\n**/\nclass Timer {\n/**\nCreates a function that delays the execution of `callback` by `delayms` every time it is\ninvoked. If `leading` is set to true, a first execution is guaranteed to happen as soon\nas the returnd function is invoked.\n**/\n  public static function debounce(callback : Void -> Void, delayms : Int, leading = false) {\n    var cancel = Functions.noop;\n    function poll() {\n      cancel();\n      cancel = Timer.delay(callback, delayms);\n    }\n    return function() {\n        if(leading) {\n          leading = false;\n          callback();\n        }\n        poll();\n    }\n  }\n\n/**\nThe returned function executes `callback` at most once every `delayms` regardless of\nhow many times it is invoked in that timespance. Setting `leading` to true ensures\nthat the callback is invoked at the beginning of the cycle.\n**/\n  public static function throttle(callback : Void -> Void, delayms : Int, leading = false) {\n    var waiting = false;\n    function poll() {\n      waiting = true;\n      Timer.delay(callback, delayms);\n    }\n    return function() {\n        if(leading) {\n          leading = false;\n          callback();\n          return;\n        }\n        if(waiting)\n          return;\n        poll();\n    };\n  }\n\n// IMPLEMENTATIONS\n\n#if !(js || flash)\n  static var timers = new Map<Int, haxe.Timer>();\n  static var _id = 0;\n#end\n\n/**\n`Timer.repeat` continues to invoke `callback` until it is cancelled using the returned\ncancel function.\n**/\n  public static function repeat(callback : Void -> Void, delayms : Int) : Void -> Void {\n#if js\n    return clear.bind(untyped __js__('setInterval')(callback, delayms));\n#elseif flash9\n    return clear.bind(untyped __global__[\"flash.utils.setInterval\"](callback, delayms));\n#elseif flash\n    return clear.bind(untyped _global[\"setInterval\"](callback, delayms));\n// #elseif java\n//     var executorService = java.util.concurrent.Executors.newSingleThreadScheduledExecutor();\n//     var handler = executorService.scheduleAtFixedRate(new TimerTask(callback), haxe.Int64.ofInt(delayms), haxe.Int64.ofInt(delayms), java.util.concurrent.TimeUnit.MILLISECONDS);\n//     return handler.cancel.bind(true);\n#elseif !lime\n    return throw \"platform does not support delays (Timer.repeat)\";\n#else\n    var id = _id++,\n        timer = new haxe.Timer(delayms);\n    timer.run = callback;\n    timers.set(id, timer);\n    return clear.bind(id);\n#end\n  }\n\n/**\n`Timer.delay` invokes `callback` after `delayms` milliseconds. The scheduling can be\ncanelled using the returned cancel function.\n**/\n  public static function delay(callback : Void -> Void, delayms : Int) : Void -> Void {\n#if js\n    return clear.bind(untyped __js__('setTimeout')(callback, delayms));\n#elseif flash9\n    return clear.bind(untyped __global__[\"flash.utils.setTimeout\"](callback, delayms));\n#elseif flash\n    return clear.bind(untyped _global[\"setTimeout\"](callback, delayms));\n// #elseif java\n//     var executorService = java.util.concurrent.Executors.newSingleThreadScheduledExecutor();\n//     var handler = executorService.schedule(new TimerTask(callback), haxe.Int64.ofInt(delayms), java.util.concurrent.TimeUnit.MILLISECONDS);\n//     return handler.cancel.bind(true);\n#elseif !lime\n    return throw \"platform does not support delays (Timer.delay)\";\n#else\n    var id = _id++,\n        timer = haxe.Timer.delay(function() {\n          callback();\n          clear(id);\n        }, delayms);\n    timers.set(id, timer);\n    return clear.bind(id);\n#end\n  }\n\n/**\nInvokes `callback` at every frame using native implementation where available. A delta time\nin milliseconds is passed since the latest time callback was invoked.\n**/\n  public static function frame(callback : Float -> Void) {\n#if js\n    var cancelled = false,\n        f = Functions.noop,\n        current = time(),\n        next;\n    f = function() {\n          if(cancelled) return;\n          next = time();\n          callback(next - current);\n          current = next;\n          untyped __js__(\"requestAnimationFrame\")(f);\n        };\n\n    untyped __js__(\"requestAnimationFrame\")(f);\n    return function() cancelled = true;\n#elseif openfl\n    var current = time(),\n        next,\n        listener = function(_) {\n          next = time();\n          callback(next - current);\n          current = next;\n        };\n    openfl.Lib.current.addEventListener(openfl.events.Event.ENTER_FRAME, listener);\n    return function()\n      openfl.Lib.current.removeEventListener(openfl.events.Event.ENTER_FRAME, listener);\n#elseif flash9\n    var current = time(),\n        next,\n        listener = function(_) {\n          next = time();\n          callback(next - current);\n          current = next;\n        };\n    flash.Lib.current.addEventListener(flash.events.Event.ENTER_FRAME, listener);\n    return function()\n      flash.Lib.current.removeEventListener(flash.events.Event.ENTER_FRAME, listener);\n#else\n    var current = time(),\n        next,\n        listener = function() {\n          next = time();\n          callback(next - current);\n          current = next;\n        };\n    return repeat(listener, FRAME_RATE);\n#end\n  }\n\n/**\nDelays `callback` untile the next frame using native implementation where available.\n**/\n  public static function nextFrame(callback : Void -> Void) {\n#if js\n    var id = untyped __js__(\"requestAnimationFrame\")(callback);\n    return function() untyped __js__(\"cancelAnimationFrame\")(id);\n#elseif openfl\n    var listener = null,\n        cancel = function() openfl.Lib.current.removeEventListener(openfl.events.Event.ENTER_FRAME, listener);\n    listener = function(_) {\n      cancel();\n      callback();\n    };\n    openfl.Lib.current.addEventListener(openfl.events.Event.ENTER_FRAME, listener);\n    return cancel;\n#elseif flash9\n    var listener = null,\n        cancel = function() flash.Lib.current.removeEventListener(flash.events.Event.ENTER_FRAME, listener);\n    listener = function(_) {\n      cancel();\n      callback();\n    };\n    flash.Lib.current.addEventListener(flash.events.Event.ENTER_FRAME, listener);\n    return cancel;\n#else\n  return delay(callback, FRAME_RATE);\n#end\n  }\n\n  static var FRAME_RATE = Math.round(1000 / 60);\n\n/**\n`Timer.immediate` works essentially like `Timer.delay` with the exception that the delay\nwill be the shortest allowed by the platform. How short the delay depends a lot on\nthe target platform.\n**/\n  public static function immediate(callback : Void -> Void) : Void -> Void\n#if js\n    return clear.bind(untyped __js__('setImmediate')(callback));\n#elseif java\n    // not sure why this is needed\n    return delay(callback, 1);\n#else\n    return delay(callback, 0);\n#end\n\n  static #if js inline #end function clear(id) : Void {\n#if js\n    return untyped __js__('clearTimeout')(id);\n#elseif flash9\n    return untyped __global__[\"flash.utils.clearTimeout\"](id);\n#elseif flash\n    return untyped _global[\"clearTimeout\"](id);\n#elseif !lime\n    return throw \"platform does not support delays (Timer.clear)\";\n#else\n    var timer = timers.get(id);\n    if(null != timer) {\n      timers.remove(id);\n      timer.stop();\n    }\n#end\n  }\n\n/**\nReturns a time value in milliseconds. Where supported, the decimal value represents microseconds.\n\nNote that the initial value might change from platform to platform so only delta measurements make sense.\n**/\n  inline public static function time() : Float\n#if js\n    return untyped __js__(\"performance\").now();\n#elseif flash\n    return flash.Lib.getTimer();\n#elseif (cpp || neko)\n    return haxe.Timer.stamp() * 1000.0;\n#elseif cs\n    return (cs.system.Environment.TickCount : Float);\n#elseif java\n    return cast(java.lang.System.nanoTime(), Float) / 1000000.0;\n#elseif php\n    return untyped __php__('microtime(true) * 1000.0');\n#elseif python\n    return python.lib.Time.clock() * 1000;\n#else\n    return throw 'Timer.time() is not implemented in this target';\n#end\n\n  static var _resolution : Null<Float>;\n  public static function resolution() : Float {\n    if(null != _resolution)\n      return _resolution;\n    var start = time(),\n        end, loop = 0.0;\n    do {\n      loop++;\n      end = Timer.time();\n    } while(end - start == 0);\n    return _resolution = end - start;\n  }\n\n#if js\n  static function __init__() untyped {\n    // Polyfills\n    // SCOPE\n    var scope : Dynamic = __js__('(\"undefined\" !== typeof window && window) || (\"undefined\" !== typeof global && global) || Function(\"return this\")()');\n\n    // setImmediate\n    if(!scope.setImmediate)\n      scope.setImmediate = function(callback) scope.setTimeout(callback, 0);\n\n    // rAF\n    // based on Paul Irish code: http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n    var lastTime = 0,\n        vendors = ['webkit', 'moz'],\n        x = 0;\n\n    while(x < vendors.length && !scope.requestAnimationFrame) {\n      scope.requestAnimationFrame = scope[vendors[x]+'RequestAnimationFrame'];\n      scope.cancelAnimationFrame = scope[vendors[x]+'CancelAnimationFrame'] || scope[vendors[x]+'CancelRequestAnimationFrame'];\n      x++;\n    }\n\n    if (!scope.requestAnimationFrame)\n      scope.requestAnimationFrame = function(callback) {\n        var currTime = Date.now().getTime(),\n            timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n            id = scope.setTimeout(function() callback(currTime + timeToCall), timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n      };\n\n    if (!scope.cancelAnimationFrame)\n      scope.cancelAnimationFrame = function(id) scope.clearTimeout(id);\n\n    // performance.now /  High Resolution Timer\n    if(__js__(\"typeof\")(scope.performance) == \"undefined\")\n      scope.performance = {};\n\n    if(__js__(\"typeof\")(scope.performance.now) == \"undefined\") {\n      var nowOffset = Date.now().getTime();\n\n      if (scope.performance.timing && scope.performance.timing.navigationStart)\n        nowOffset = scope.performance.timing.navigationStart;\n\n      scope.performance.now = function now()\n        return Date.now() - nowOffset;\n    }\n  }\n#end\n}\n\n#if java\n@:nativeGen private class TimerTask extends java.util.TimerTask {\n  var callback : Void -> Void;\n  public function new(callback : Void -> Void) : Void {\n    super();\n    this.callback = callback;\n  }\n\n  @:overload override public function run()\n    callback();\n}\n#end\n","package thx.error;\n\nimport haxe.PosInfos;\nimport haxe.CallStack;\n\n/**\nAn error that keeps a reference to an internal error.\n\nThe internal error is stored as Dynamic to keep its usage flexible.\n*/\nclass ErrorWrapper extends thx.Error {\n  public var innerError : Dynamic;\n  public function new(message : String, innerError : Dynamic, ?stack : Array<StackItem>, ?pos : PosInfos) {\n    super(message, stack, pos);\n\n    this.innerError = innerError;\n  }\n}\n","package thx.promise;\n\nimport haxe.ds.Option;\nusing thx.Arrays;\nimport thx.Error;\nimport thx.Nil;\nusing thx.Options;\nimport thx.Tuple;\n\nclass Future<T> {\n  public static function sequence<T>(arr : Array<Future<T>>) : Future<Array<T>>\n    return Future.create(function(callback : Array<T> -> Void) {\n        var acc = [];\n        function poll(index : Int) {\n          if(index == arr.length)\n            return callback(acc);\n          arr[index]\n            .then(function(v) {\n              acc[index] = v;\n              poll(index+1);\n            });\n        }\n        poll(0);\n      });\n\n#if java // seriously?\npublic static function afterAll<T>(arr : Array<Future<T>>) : Future<Nil>\n  return Future.create(function(callback : Nil -> Void) {\n      function poll(index : Int) {\n        if(index == arr.length)\n          return callback(Nil.nil);\n        arr[index]\n          .then(function(_) {\n            poll(index+1);\n          });\n      }\n      poll(0);\n    });\n#else\n  public static function afterAll(arr : Array<Future<Dynamic>>) : Future<Nil>\n    return sequence(arr).nil();\n#end\n\n  @:deprecated('Future.all is deprecated, use Future.sequence instead')\n  public static function all<T>(arr : Array<Future<T>>) : Future<Array<T>>\n    return sequence(arr);\n\n  public static function create<T>(handler : (T -> Void) -> Void) : Future<T> {\n    var future = new Future<T>();\n    handler(future.setState);\n    return future;\n  }\n\n  inline public static function flatten<T>(future : Future<Future<T>>) : Future<T>\n    return Future.create(function(callback) {\n      future.then(function(future) future.then(callback));\n    });\n\n  public static function value<T>(v : T)\n    return create(function(callback) callback(v));\n\n  var handlers : Array<T -> Void>;\n  public var state(default, null) : Option<T>;\n  private function new() {\n    handlers = [];\n    state = None;\n  }\n\n#if (js || flash)\n  inline public function delay(?delayms : Int) {\n    if(null == delayms)\n      return flatMap(function(v) return Timer.immediateValue(v));\n    else\n      return flatMap(function(v) return Timer.delayValue(v, delayms));\n  }\n#end\n\n  inline public function hasValue()\n    return state.toBool();\n\n  public function map<TOut>(handler : T -> TOut) : Future<TOut>\n    return Future.create(function(callback)\n      then(function(v) callback(handler(v))));\n\n  public function mapAsync<TOut>(handler : T -> (TOut -> Void) -> Void) : Future<TOut>\n    return Future.create(function(callback)\n      then(function(result : T )\n        handler(result, callback)));\n\n  public function mapPromise<TOut>(handler : T -> Promise<TOut>) : Promise<TOut>\n    return Promise.create(function(resolve, reject)\n      then(function(result : T)\n        handler(result)\n          .success(resolve)\n          .failure(reject)));\n\n  public function nil() : Future<Nil>\n    return map(function(_) return Nil.nil);\n\n  @:deprecated(\"Future.mapFuture is deprecated, use Future.flatMap\")\n  inline public function mapFuture<TOut>(handler : T -> Future<TOut>) : Future<TOut>\n    return flatMap(handler);\n\n  public function flatMap<TOut>(handler : T -> Future<TOut>) : Future<TOut>\n    return Future.create(function(callback)\n      then(function(v) handler(v).then(callback)));\n\n  public function then(handler : T -> Void): Future<T> {\n    handlers.push(handler);\n    update();\n    return this;\n  }\n\n  public function toString() return 'Future';\n\n  function setState(newstate : T) {\n    switch state {\n      case None:\n        state = Some(newstate);\n      case Some(r):\n        throw new Error('future was already \"$r\", can\\'t apply the new state \"$newstate\"');\n    }\n    update();\n    return this;\n  }\n\n  function update() {\n    switch state {\n      case None:\n      case Some(result): {\n        var index = -1;\n        while(++index < handlers.length) {\n          var handler = handlers[index];\n          handler(result);\n        }\n        handlers = [];\n      }\n    };\n  }\n}\n\nclass Futures {\n  public static function join<T1,T2>(p1 : Future<T1>, p2 : Future<T2>) : Future<Tuple2<T1,T2>> {\n    return Future.create(function(callback) {\n      var counter = 0,\n          v1 : Null<T1> = null,\n          v2 : Null<T2> = null;\n\n      function complete() {\n        if(counter < 2)\n          return;\n        callback(new Tuple2(v1, v2));\n      }\n\n      p1.then(function(v) {\n        counter++;\n        v1 = v;\n        complete();\n      });\n\n      p2.then(function(v) {\n        counter++;\n        v2 = v;\n        complete();\n      });\n    });\n  }\n\n  public static function log<T>(future : Future<T>, ?prefix : String = '')\n    return future.then(\n      function(r) trace('$prefix VALUE: $r')\n    );\n}\n\nclass FutureTuple6 {\n  public static function mapTuple<T1,T2,T3,T4,T5,T6,TOut>(future : Future<Tuple6<T1,T2,T3,T4,T5,T6>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> TOut) : Future<TOut>\n    return future.map(function(t)\n      return callback(t._0, t._1, t._2, t._3, t._4, t._5)\n    );\n\n  public static function mapTupleAsync<T1,T2,T3,T4,T5,T6,TOut>(future : Future<Tuple6<T1,T2,T3,T4,T5,T6>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, t._2, t._3, t._4, t._5, cb));\n\n  public static function mapTupleFuture<T1,T2,T3,T4,T5,T6,TOut>(future : Future<Tuple6<T1,T2,T3,T4,T5,T6>>, callback : T1 -> T2 -> T3  -> T4 -> T5 -> T6 -> Future<TOut>) : Future<TOut>\n    return future.flatMap(function(t) return callback(t._0, t._1, t._2, t._3, t._4, t._5));\n\n  public static function tuple<T1,T2,T3,T4,T5,T6>(future : Future<Tuple6<T1,T2,T3,T4,T5,T6>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> Void)\n    return future.then(function(t) callback(t._0, t._1, t._2, t._3, t._4, t._5));\n}\n\nclass FutureTuple5 {\n  public static function join<T1,T2,T3,T4,T5,T6>(p1 : Future<Tuple5<T1,T2,T3,T4,T5>>, p2 : Future<T6>) : Future<Tuple6<T1,T2,T3,T4,T5,T6>>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(\n          function(t) callback(t._0.with(t._1))));\n\n  public static function mapTuple<T1,T2,T3,T4,T5,TOut>(future : Future<Tuple5<T1,T2,T3,T4,T5>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> TOut) : Future<TOut>\n    return future.map(function(t)\n      return callback(t._0, t._1, t._2, t._3, t._4)\n    );\n\n  public static function mapTupleAsync<T1,T2,T3,T4,T5,TOut>(future : Future<Tuple5<T1,T2,T3,T4,T5>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, t._2, t._3, t._4, cb));\n\n  public static function mapTupleFuture<T1,T2,T3,T4,T5,TOut>(future : Future<Tuple5<T1,T2,T3,T4,T5>>, callback : T1 -> T2 -> T3  -> T4 -> T5 -> Future<TOut>) : Future<TOut>\n    return future.flatMap(function(t) return callback(t._0, t._1, t._2, t._3, t._4));\n\n  public static function tuple<T1,T2,T3,T4,T5>(future : Future<Tuple5<T1,T2,T3,T4,T5>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> Void)\n    return future.then(function(t) callback(t._0, t._1, t._2, t._3, t._4));\n}\n\nclass FutureTuple4 {\n  public static function join<T1,T2,T3,T4,T5>(p1 : Future<Tuple4<T1,T2,T3,T4>>, p2 : Future<T5>) : Future<Tuple5<T1,T2,T3,T4,T5>>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(\n          function(t) callback(t._0.with(t._1))));\n\n  public static function mapTuple<T1,T2,T3,T4,TOut>(future : Future<Tuple4<T1,T2,T3,T4>>, callback : T1 -> T2 -> T3 -> T4 -> TOut) : Future<TOut>\n    return future.map(function(t)\n      return callback(t._0, t._1, t._2, t._3)\n    );\n\n  public static function mapTupleAsync<T1,T2,T3,T4,TOut>(future : Future<Tuple4<T1,T2,T3,T4>>, callback : T1 -> T2 -> T3 -> T4 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, t._2, t._3, cb));\n\n  public static function mapTupleFuture<T1,T2,T3,T4,TOut>(future : Future<Tuple4<T1,T2,T3,T4>>, callback : T1 -> T2 -> T3  -> T4 -> Future<TOut>) : Future<TOut>\n    return future.flatMap(function(t) return callback(t._0, t._1, t._2, t._3));\n\n  public static function tuple<T1,T2,T3,T4>(future : Future<Tuple4<T1,T2,T3,T4>>, callback : T1 -> T2 -> T3 -> T4 -> Void)\n    return future.then(function(t) callback(t._0, t._1, t._2, t._3));\n}\n\nclass FutureTuple3 {\n  public static function join<T1,T2,T3,T4>(p1 : Future<Tuple3<T1,T2,T3>>, p2 : Future<T4>) : Future<Tuple4<T1,T2,T3,T4>>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(\n          function(t) callback(t._0.with(t._1))));\n\n  public static function mapTuple<T1,T2,T3,TOut>(future : Future<Tuple3<T1,T2,T3>>, callback : T1 -> T2 -> T3 -> TOut) : Future<TOut>\n    return future.map(function(t)\n      return callback(t._0, t._1, t._2)\n    );\n\n  public static function mapTupleAsync<T1,T2,T3,TOut>(future : Future<Tuple3<T1,T2,T3>>, callback : T1 -> T2 -> T3 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, t._2, cb));\n\n  public static function mapTupleFuture<T1,T2,T3,TOut>(future : Future<Tuple3<T1,T2,T3>>, callback : T1 -> T2 -> T3  -> Future<TOut>) : Future<TOut>\n    return future.flatMap(function(t) return callback(t._0, t._1, t._2));\n\n  public static function tuple<T1,T2,T3>(future : Future<Tuple3<T1,T2,T3>>, callback : T1 -> T2 -> T3 -> Void)\n    return future.then(function(t) callback(t._0, t._1, t._2));\n}\n\nclass FutureTuple2 {\n  public static function join<T1,T2,T3>(p1 : Future<Tuple2<T1,T2>>, p2 : Future<T3>) : Future<Tuple3<T1,T2,T3>>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(function(t) callback(t._0.with(t._1))));\n\n  public static function mapTuple<T1,T2,TOut>(future : Future<Tuple2<T1,T2>>, callback : T1 -> T2 -> TOut) : Future<TOut>\n    return future.map(function(t) return callback(t._0, t._1));\n\n  public static function mapTupleAsync<T1,T2,TOut>(future : Future<Tuple2<T1,T2>>, callback : T1 -> T2 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, cb));\n\n  public static function mapTupleFuture<T1,T2,TOut>(future : Future<Tuple2<T1,T2>>, callback : T1 -> T2 -> Future<TOut>) : Future<TOut>\n    return future.flatMap(function(t) return callback(t._0, t._1));\n\n  public static function tuple<T1,T2>(future : Future<Tuple2<T1,T2>>, callback : T1 -> T2 -> Void)\n    return future.then(function(t) callback(t._0, t._1));\n}\n\nclass FutureNil {\n  public static function join<T2>(p1 : Future<Nil>, p2 : Future<T2>) : Future<T2>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(function(t) callback(t._1)));\n\n  public static function nil(p : Future<Dynamic>) : Future<Nil>\n    return Future.create(function(callback : Nil -> Void)\n      p.then(function(_) callback(Nil.nil)));\n}\n","package thx.promise;\n\nimport haxe.ds.Option;\n\nimport thx.Either;\nimport thx.Error;\nimport thx.Nil;\nimport thx.Result;\nimport thx.Tuple;\nimport thx.fp.Functions.const;\n\nusing thx.Arrays;\nusing thx.Functions;\nusing thx.Options;\n\ntypedef PromiseValue<T> = Result<T, Error>;\n\n@:forward(hasValue, mapAsync, state, then)\nabstract Promise<T>(Future<Result<T, Error>>) to Future<Result<T, Error>> {\n  inline private function new(future: Future<Result<T, Error>>)\n    this = future;\n\n  public static function fromFuture<T>(future : Future<T>) : Promise<T>\n    return new Promise(future.map(function(v) return (Right(v) : PromiseValue<T>)));\n\n  // Note: this can be a static var again, when the issue #19 with promise reuse is fixed\n  //public static var nil(default, null) : Promise<Nil> = Promise.value(Nil.nil);\n  public static var nil(get, null) : Promise<Nil>;\n  static function get_nil() : Promise<Nil> return Promise.value(Nil.nil);\n\n  @:deprecated(\"Use Promise.sequence instead; since Promise construction is eager there is no difference between the two.\")\n  public static function all<T>(arr : Array<Promise<T>>) : Promise<Array<T>> {\n    return if (arr.length == 0) Promise.value([])\n    else Promise.create(\n      function(resolve, reject) {\n        var results  = [],\n            counter  = 0,\n            hasError = false;\n\n        // For each element of the array, mutate the results completion. When\n        // all results have been included, or an error is encountered, resolve\n        // the resulting promise.\n        for (i in 0...arr.length) {\n          arr[i].either(\n            function(v) {\n              if (!hasError) {\n                results[i] = v;\n                counter++;\n\n                if(counter == arr.length) resolve(results);\n              }\n            },\n            function(err) {\n              if (!hasError) {\n                hasError = true;\n                reject(err);\n              }\n            }\n          );\n        }\n      }\n    );\n  }\n\n  public static function afterAll(arr : Array<Promise<Dynamic>>) : Promise<Nil>\n    return sequence(arr).map(const(Nil.nil));\n\n  public static function sequence<T>(arr : Array<Promise<T>>) : Promise<Array<T>> {\n    return arr.reduce(\n      function(acc: Promise<Array<T>>, p: Promise<T>) return acc.flatMap(\n        function(arr: Array<T>) return p.map(function(t) return arr.concat([t]))\n      ),\n      Promise.value([])\n    );\n  }\n\n  @:deprecated(\"Use Promise.sequence instead.\")\n  public static function allSequence<T>(arr : Array<Promise<T>>) : Promise<Array<T>>\n    return sequence(arr);\n\n  public static function create<T>(callback : (T -> Void) -> (Error -> Void) -> Void) : Promise<T>\n    return new Promise(\n      Future.create(function(cb : PromiseValue<T> -> Void) {\n        try {\n          callback(\n            function(v : T)     cb((Right(v) : PromiseValue<T>)),\n            function(e : Error) cb((Left(e) : PromiseValue<T>))\n          );\n        } catch(e : Dynamic) {\n          cb((Left(Error.fromDynamic(e)) : PromiseValue<T>));\n        }\n      })\n    );\n\n  public static function createUnsafe<T>(callback : (T -> Void) -> (Error -> Void) -> Void) : Promise<T>\n    return new Promise(\n      Future.create(function(cb : PromiseValue<T> -> Void) {\n        callback(\n          function(v : T)     cb((Right(v) : PromiseValue<T>)),\n          function(e : Error) cb((Left(e) : PromiseValue<T>))\n        );\n      })\n    );\n\n  public static function createFulfill<T>(callback : (PromiseValue<T> -> Void) -> Void) : Promise<T>\n    return new Promise(Future.create(function(cb) {\n      try callback(cb) catch(e : Dynamic) cb(Left(Error.fromDynamic(e)));\n    }));\n\n  public static function fail<T>(message : String, ?pos : haxe.PosInfos) : Promise<T>\n    return error(new thx.Error(message, pos));\n\n  public static function error<T>(err : Error) : Promise<T>\n    return Promise.create(function(_, reject) reject(err));\n\n  public static function value<T>(v : T) : Promise<T>\n    return Promise.create(function(resolve, _) resolve(v));\n\n  public function always(handler : Void -> Void) : Promise<T>\n    return new Promise(\n      Future.create(function(cb : PromiseValue<T> -> Void) {\n        this.then(function(v) {\n          try {\n            handler();\n            cb(v);\n          } catch(e : Dynamic) {\n            cb(Left(Error.fromDynamic(e)));\n          }\n        });\n      })\n    );\n\n  public function either(success : T -> Void, failure : Error -> Void) : Promise<T>\n    return Promise.createUnsafe(function(resolve : T -> Void, reject : Error -> Void) {\n      this.then(function(r) {\n        try {\n          switch r {\n            case Right(v):\n              success(v);\n              resolve(v);\n            case Left(e):\n              failure(e);\n              reject(e);\n          }\n        } catch(e : Dynamic) {\n          reject(Error.fromDynamic(e));\n        }\n      });\n    });\n\n#if (js || flash)\n  public function delay(?delayms : Int) : Promise<T>\n    return new Promise(this.delay(delayms));\n#end\n\n  public function isFailure() : Bool\n    return switch this.state {\n      case None, Some(Right(_)): false;\n      case _: true;\n    };\n\n  public function isResolved() : Bool\n    return switch this.state {\n      case None, Some(Left(_)): false;\n      case _: true;\n    };\n\n  public function isPending() : Bool\n    return switch this.state {\n      case Some(_): false;\n      case None: true;\n    };\n\n  public function failure(failure : Error -> Void) : Promise<T>\n    return either(function(_){}, failure);\n\n  inline public function mapAlways<TOut>(handler : Void -> TOut) : Promise<TOut>\n    return map(function(_) return handler());\n\n  inline public function mapAlwaysAsyncFuture<TOut>(handler : (TOut -> Void) -> Void) : Future<TOut>\n    return this.mapAsync(function(_, cb) return handler(cb));\n\n  inline public function mapAlwaysFuture<TOut>(handler : Void -> Future<TOut>) : Future<TOut>\n    return this.flatMap(function(_) return handler());\n\n  public function mapEither<TOut>(success : T -> TOut, failure : Error -> TOut) : Promise<TOut>\n    return flatMapEither(\n      function(v) return Promise.value(success(v)),\n      function(e) return Promise.value(failure(e))\n    );\n\n  public function mapEitherFuture<TOut>(success : T -> TOut, failure : Error -> TOut) : Future<TOut>\n    return flatMapEitherFuture(\n      function(v) return Future.value(success(v)),\n      function(e) return Future.value(failure(e))\n    );\n\n  public function flatMapEitherFuture<TOut>(success : T -> Future<TOut>, failure : Error -> Future<TOut>) : Future<TOut>\n    return this.flatMap(function(result : Result<T, Error>)\n      return switch result {\n        case Right(v): success(v);\n        case Left(e):  failure(e);\n      });\n\n  public function flatMapEither<TOut>(success : T -> Promise<TOut>, failure : Error -> Promise<TOut>) : Promise<TOut> {\n    return Promise.createUnsafe(function(resolve : TOut -> Void, reject : Error -> Void) {\n      this.then(function(result : Result<T, Error>) : Void {\n        switch result {\n          case Right(v): try success(v).either(resolve, reject) catch(e : Dynamic) reject(Error.fromDynamic(e));\n          case Left(e):  try failure(e).either(resolve, reject) catch(e : Dynamic) reject(Error.fromDynamic(e));\n        }\n      });\n    });\n  }\n\n  @:deprecated(\"Promise.mapFailure is deprecated, use Promise.recoverAsFuture instead\")\n  public function mapFailure(failure : Error -> T) : Future<T>\n    return mapEitherFuture(function(v : T) return v, failure);\n\n  @:deprecated(\"Promise.mapFailureFuture is deprecated, use Promise.recover instead\")\n  public function mapFailureFuture(failure : Error -> Future<T>) : Future<T>\n    return flatMapEitherFuture(function(v : T) return Future.value(v), failure);\n\n  @:deprecated(\"Promise.mapFailurePromise is deprecated, use Promise.recover instead\")\n  public function mapFailurePromise(failure : Error -> Promise<T>) : Promise<T>\n    return recover(failure);\n\n  public function recover(failure : Error -> Promise<T>) : Promise<T>\n    return flatMapEither(function(v) return Promise.value(v), failure);\n\n  public function recoverAsFuture(failure : Error -> T) : Future<T>\n    return mapEitherFuture(function(v : T) return v, failure);\n\n  public function map<U>(success : T -> U) : Promise<U>\n    return flatMap(function(v) return Promise.value(success(v)));\n\n  public function ap<U>(pf: Promise<T -> U>): Promise<U>\n    return flatMap(function(t) return pf.map.fn(_(t)));\n\n  @:deprecated(\"mapSuccess is deprecated. Use map instead\")\n  inline public function mapSuccess<TOut>(success : T -> TOut) : Promise<TOut>\n    return map(success);\n\n  inline public function flatMap<TOut>(success : T -> Promise<TOut>) : Promise<TOut>\n    return flatMapEither(success, function(err) return Promise.error(err));\n\n  inline public function append<TOut>(success : Void -> Promise<TOut>) : Promise<TOut>\n    return flatMap(function(_) return success());\n\n  @:op(A >> B)\n  inline public function andThen<B>(next: Void -> Promise<B>): Promise<B>\n    return flatMap(function(_) return next());\n\n  /**\n   * Performs an additional effect with the result of this promise, and\n   * when it completes ignore the resulting value and instead return\n   * the result of this promise. This is similar to success(...)\n   * except that the additional side effect expressed in the result of `f`\n   * must complete before computation can proceed.\n   */\n  inline public function foreachM<U>(f: T -> Promise<U>): Promise<T>\n    return flatMap(function(t) return f(t).map(const(t)));\n\n  @:deprecated(\"Promise.mapSuccessPromise is deprecated. Use Promise.flatMap instead\")\n  public function mapSuccessPromise<TOut>(success : T -> Promise<TOut>) : Promise<TOut>\n    return flatMap(success);\n\n  @:deprecated(\"Promise.mapNull is deprecated. Use Promise.recoverNull instead\")\n  public function mapNull(handler : Void -> Promise<Null<T>>) : Promise<T>\n    return recoverNull(handler);\n\n  public function recoverNull(handler : Void -> Promise<Null<T>>) : Promise<T>\n    return flatMap(function(v : Null<T>) {\n      if(null == v)\n        return handler();\n      else\n        return Promise.value(v);\n    });\n\n  public function success(success : T -> Void) : Promise<T>\n    return either(success, function(_){});\n\n  public function throwFailure() : Promise<T>\n    return new Promise(this.then(function(r) switch r {\n      case Left(err): throw err;\n      case _: // do nothing\n    }));\n\n  public function toString() return 'Promise';\n\n  inline public function toFuture() : Future<PromiseValue<T>> return this;\n}\n\nclass Promises {\n  public static function par<T1,T2,T3>(f: T1 -> T2 -> T3, p1 : Promise<T1>, p2 : Promise<T2>) : Promise<T3> {\n    return Promise.create(function(resolve, reject) {\n      var hasError = false,\n          counter = 0,\n          v1 : Null<T1> = null,\n          v2 : Null<T2> = null;\n\n      function complete() {\n        if(counter < 2)\n          return;\n        resolve(f(v1, v2));\n      }\n\n      function handleError(error) {\n        if(hasError) return;\n        hasError = true;\n        reject(error);\n      }\n\n      p1.either(function(v) {\n        if(hasError) return;\n        counter++;\n        v1 = v;\n        complete();\n      }, handleError);\n\n      p2.either(function(v) {\n        if(hasError) return;\n        counter++;\n        v2 = v;\n        complete();\n      }, handleError);\n    });\n  }\n\n  public static function par3<T1, T2, T3, T4>(f: T1 -> T2 -> T3 -> T4, p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>) : Promise<T4>\n    return par(function(f, g) return f(g), par(f.curry(), p1, p2), p3);\n\n  public static function par4<T1, T2, T3, T4, T5>(f: T1 -> T2 -> T3 -> T4 -> T5, p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>, p4 : Promise<T4>) : Promise<T5>\n    return par(function(f, g) return f(g), par3(f.curry(), p1, p2, p3), p4);\n\n  public static function par5<T1, T2, T3, T4, T5, T6>(f: T1 -> T2 -> T3 -> T4 -> T5 -> T6, p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>, p4 : Promise<T4>, p5: Promise<T5>):Promise<T6>\n    return par(function(f, g) return f(g), par4(f.curry(), p1, p2, p3, p4), p5);\n\n  public static function par6<T1, T2, T3, T4, T5, T6, T7>(f: T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> T7, p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>, p4 : Promise<T4>, p5: Promise<T5>, p6: Promise<T6>): Promise<T7>\n    return par(function(f, g) return f(g), par5(f.curry(), p1, p2, p3, p4, p5), p6);\n\n  inline public static function join<T1,T2>(p1 : Promise<T1>, p2 : Promise<T2>) : Promise<Tuple2<T1,T2>>\n    return par(Tuple.of, p1, p2);\n\n  // alias for join\n  inline public static function join2<T1,T2>(p1 : Promise<T1>, p2 : Promise<T2>) : Promise<Tuple2<T1,T2>>\n    return join(p1, p2);\n\n  public static function join3<T1, T2, T3>(p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>) : Promise<Tuple3<T1, T2, T3>>\n    return par3(Tuple3.of, p1, p2, p3);\n\n  public static function join4<T1, T2, T3, T4>(p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>, p4 : Promise<T4>) : Promise<Tuple4<T1, T2, T3, T4>>\n    return par4(Tuple4.of, p1, p2, p3, p4);\n\n  public static function join5<T1, T2, T3, T4, T5>(p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>, p4 : Promise<T4>, p5 : Promise<T5>) : Promise<Tuple5<T1, T2, T3, T4, T5>>\n    return par5(Tuple5.of, p1, p2, p3, p4, p5);\n\n  public static function join6<T1, T2, T3, T4, T5, T6>(p1 : Promise<T1>, p2 : Promise<T2>, p3 : Promise<T3>, p4 : Promise<T4>, p5 : Promise<T5>, p6 : Promise<T6>) : Promise<Tuple6<T1, T2, T3, T4, T5, T6>>\n    return par6(Tuple6.of, p1, p2, p3, p4, p5, p6);\n\n  public static function log<T>(promise : Promise<T>, ?prefix : String = '')\n    return promise.either(\n      function(r) trace('$prefix SUCCESS: $r'),\n      function(e) trace('$prefix ERROR: ${e.toString()}')\n    );\n}\n\nclass PromiseTuple6 {\n  public static function mapTuplePromise<T1,T2,T3,T4,T5,T6,TOut>(promise : Promise<Tuple6<T1,T2,T3,T4,T5,T6>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> Promise<TOut>) : Promise<TOut>\n    return promise.flatMap(function(t)\n      return success(t._0, t._1, t._2, t._3, t._4, t._5)\n    );\n\n  public static function mapTuple<T1,T2,T3,T4,T5,T6,TOut>(promise : Promise<Tuple6<T1,T2,T3,T4,T5,T6>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> TOut) : Promise<TOut>\n    return promise.map(function(t)\n      return success(t._0, t._1, t._2, t._3, t._4, t._5)\n    );\n\n  public static function tuple<T1,T2,T3,T4,T5,T6>(promise : Promise<Tuple6<T1,T2,T3,T4,T5,T6>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2, t._3, t._4, t._5),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple5 {\n  public static function join<T1,T2,T3,T4,T5,T6>(p1 : Promise<Tuple5<T1,T2,T3,T4,T5>>, p2 : Promise<T6>) : Promise<Tuple6<T1,T2,T3,T4,T5,T6>>\n    return Promises.par(function(f: Tuple5<T1,T2,T3,T4,T5>, g: T6) return f.with(g), p1, p2);\n\n  public static function mapTuplePromise<T1,T2,T3,T4,T5,TOut>(promise : Promise<Tuple5<T1,T2,T3,T4,T5>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> Promise<TOut>) : Promise<TOut>\n    return promise.flatMap(function(t)\n      return success(t._0, t._1, t._2, t._3, t._4)\n    );\n\n  public static function mapTuple<T1,T2,T3,T4,T5,TOut>(promise : Promise<Tuple5<T1,T2,T3,T4,T5>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> TOut) : Promise<TOut>\n    return promise.map(function(t)\n      return success(t._0, t._1, t._2, t._3, t._4)\n    );\n\n  public static function tuple<T1,T2,T3,T4,T5>(promise : Promise<Tuple5<T1,T2,T3,T4,T5>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2, t._3, t._4),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple4 {\n  public static function join<T1,T2,T3,T4,T5>(p1 : Promise<Tuple4<T1,T2,T3,T4>>, p2 : Promise<T5>) : Promise<Tuple5<T1,T2,T3,T4,T5>>\n    return Promises.par(function(f: Tuple4<T1,T2,T3,T4>, g: T5) return f.with(g), p1, p2);\n\n  public static function mapTuplePromise<T1,T2,T3,T4,TOut>(promise : Promise<Tuple4<T1,T2,T3,T4>>, success : T1 -> T2 -> T3 -> T4 -> Promise<TOut>) : Promise<TOut>\n    return promise.flatMap(function(t)\n      return success(t._0, t._1, t._2, t._3)\n    );\n\n  public static function mapTuple<T1,T2,T3,T4,TOut>(promise : Promise<Tuple4<T1,T2,T3,T4>>, success : T1 -> T2 -> T3 -> T4 -> TOut) : Promise<TOut>\n    return promise.map(function(t)\n      return success(t._0, t._1, t._2, t._3)\n    );\n\n  public static function tuple<T1,T2,T3,T4>(promise : Promise<Tuple4<T1,T2,T3,T4>>, success : T1 -> T2 -> T3 -> T4 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2, t._3),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple3 {\n  public static function join<T1,T2,T3,T4>(p1 : Promise<Tuple3<T1,T2,T3>>, p2 : Promise<T4>) : Promise<Tuple4<T1,T2,T3,T4>>\n    return Promises.par(function(f: Tuple3<T1, T2, T3>, g: T4) return f.with(g), p1, p2);\n\n  public static function mapTuplePromise<T1,T2,T3,TOut>(promise : Promise<Tuple3<T1,T2,T3>>, success : T1 -> T2 -> T3 -> Promise<TOut>) : Promise<TOut>\n    return promise.flatMap(function(t)\n      return success(t._0, t._1, t._2)\n    );\n\n  public static function mapTuple<T1,T2,T3,TOut>(promise : Promise<Tuple3<T1,T2,T3>>, success : T1 -> T2 -> T3 -> TOut) : Promise<TOut>\n    return promise.map(function(t)\n      return success(t._0, t._1, t._2)\n    );\n\n  public static function tuple<T1,T2,T3>(promise : Promise<Tuple3<T1,T2,T3>>, success : T1 -> T2 -> T3 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple2 {\n  public static function join<T1,T2,T3>(p1 : Promise<Tuple2<T1,T2>>, p2 : Promise<T3>) : Promise<Tuple3<T1,T2,T3>>\n    return Promises.par(function(f: Tuple2<T1, T2>, g: T3) return f.with(g), p1, p2);\n\n  public static function mapTuplePromise<T1,T2,TOut>(promise : Promise<Tuple2<T1,T2>>, success : T1 -> T2 -> Promise<TOut>) : Promise<TOut>\n    return promise.flatMap(function(t)\n      return success(t._0, t._1)\n    );\n\n  public static function mapTuple<T1,T2,TOut>(promise : Promise<Tuple2<T1,T2>>, success : T1 -> T2 -> TOut) : Promise<TOut>\n    return promise.map(function(t)\n      return success(t._0, t._1)\n    );\n\n  public static function tuple<T1,T2>(promise : Promise<Tuple2<T1,T2>>, success : T1 -> T2 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseNil {\n  public static function join<T2>(p1 : Promise<Nil>, p2 : Promise<T2>) : Promise<T2>\n    return Promises.par(function(_, g) return g, p1, p2);\n\n  public static function nil<A>(p : Promise<A>) : Promise<Nil>\n    return p.map(const(Nil.nil));\n}\n\n#if js\nclass PromiseAPlus {\n  public static function promise<T>(p : js.Promise<T>, ?pos : haxe.PosInfos) : Promise<T>\n    return Promise.create(function(resolve, reject) {\n      p.then(resolve, function(e) reject(Error.fromDynamic(e, pos)));\n    });\n\n  public static function aPlus<T>(p : Promise<T>) : js.Promise<T>\n    return new js.Promise(function(resolve, reject) {\n        p.success(resolve).failure(reject);\n      });\n}\n\nclass PromiseAPlusVoid {\n  public static function promise(p : js.Promise<Void>, ?pos : haxe.PosInfos) : Promise<Nil>\n    return Promise.create(function(resolve, reject) {\n      p.then(cast function() resolve(nil), function(e) reject(Error.fromDynamic(e, pos)));\n    });\n\n  public static function aPlus(p : Promise<Void>) : js.Promise<Nil>\n    return new js.Promise(function(resolve, reject) {\n        p.success(cast function() resolve(nil)).failure(reject);\n      });\n}\n#end\n"],
"names":[],
"mappings":"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"
}